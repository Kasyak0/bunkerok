<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bunker Game - Online</title>

<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
background: linear-gradient(135deg, #1a0b2e 0%, #2d1b4e 50%, #3d2c5f 100%);
color: #ffffff;
min-height: 100vh;
overflow-x: hidden;
}

.container {
max-width: 1400px;
margin: 0 auto;
padding: 20px;
position: relative;
z-index: 1;
}

.screen {
min-height: 100vh;
position: relative;
}

.screen.hidden {
display: none !important;
}

.btn {
padding: 12px 24px;
border: none;
border-radius: 12px;
font-size: 16px;
font-weight: 600;
cursor: pointer;
transition: all 0.3s ease;
background: linear-gradient(135deg, #6a4c93 0%, #8e44ad 100%);
color: white;
box-shadow: 0 4px 15px rgba(106, 76, 147, 0.3);
margin: 5px;
}

.btn:hover {
transform: translateY(-2px);
box-shadow: 0 6px 20px rgba(106, 76, 147, 0.4);
background: linear-gradient(135deg, #7a5ca3 0%, #9e54bd 100%);
}

.btn:disabled {
opacity: 0.6;
cursor: not-allowed;
transform: none;
}

.card {
background: rgba(255, 255, 255, 0.05);
backdrop-filter: blur(10px);
border: 1px solid rgba(255, 255, 255, 0.1);
border-radius: 16px;
padding: 20px;
transition: all 0.3s ease;
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
margin: 15px 0;
}

h1 {
font-size: 3rem;
font-weight: 700;
text-align: center;
background: linear-gradient(135deg, #ffffff 0%, #e0c3fc 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
margin-bottom: 30px;
}

.input {
width: 100%;
padding: 12px 16px;
border: 1px solid rgba(255, 255, 255, 0.2);
border-radius: 12px;
background: rgba(255, 255, 255, 0.05);
color: white;
font-size: 16px;
transition: all 0.3s ease;
backdrop-filter: blur(10px);
margin: 10px 0;
}

.input:focus {
outline: none;
border-color: #8e44ad;
box-shadow: 0 0 0 3px rgba(142, 68, 173, 0.2);
background: rgba(255, 255, 255, 0.08);
}

.input::placeholder {
color: rgba(255, 255, 255, 0.5);
}

.status {
position: fixed;
top: 20px;
right: 20px;
padding: 8px 16px;
border-radius: 20px;
font-size: 12px;
font-weight: 600;
z-index: 1000;
background: #2ecc71;
color: white;
}

.status.offline {
background: #e74c3c;
}

.status.connecting {
background: #f39c12;
}

.error {
background: rgba(231, 76, 60, 0.1);
border: 1px solid rgba(231, 76, 60, 0.5);
color: #e74c3c;
padding: 15px;
border-radius: 12px;
margin: 20px 0;
text-align: center;
}

.players-list {
display: flex;
flex-wrap: wrap;
gap: 15px;
justify-content: center;
margin: 20px 0;
}

.player-item {
padding: 10px 20px;
background: rgba(255, 255, 255, 0.1);
border: 1px solid rgba(255, 255, 255, 0.2);
border-radius: 8px;
color: white;
font-weight: 500;
display: flex;
justify-content: space-between;
align-items: center;
}

.kick-btn {
padding: 5px 10px;
font-size: 12px;
background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
color: white;
border: none;
border-radius: 4px;
cursor: pointer;
transition: all 0.2s ease;
}

.kick-btn:hover {
background: linear-gradient(135deg, #c0392b 0%, #a93226 100%);
transform: translateY(-1px);
}

.skip-btn {
padding: 8px 16px;
font-size: 14px;
background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
color: white;
border: none;
border-radius: 6px;
cursor: pointer;
transition: all 0.2s ease;
}

.skip-btn:hover {
background: linear-gradient(135deg, #e67e22 0%, #d68910 100%);
transform: translateY(-1px);
}

        .end-game-btn {
            padding: 8px 16px;
            font-size: 14px;
            background: linear-gradient(135deg, #8e44ad 0%, #7d3c98 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .end-game-btn:hover {
            background: linear-gradient(135deg, #7d3c98 0%, #6c3483 100%);
            transform: translateY(-1px);
        }
        
        .end-voting-btn {
            padding: 8px 16px;
            font-size: 14px;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .end-voting-btn:hover {
            background: linear-gradient(135deg, #c0392b 0%, #a93226 100%);
            transform: translateY(-1px);
        }
        
/* Game Cards */
.player-card {
background: rgba(255, 255, 255, 0.05);
border: 1px solid rgba(255, 255, 255, 0.1);
border-radius: 16px;
padding: 20px;
min-height: 400px;
transition: all 0.3s ease;
}

.player-card.current-player {
border-color: #8e44ad;
box-shadow: 0 0 20px rgba(142, 68, 173, 0.3);
}

.player-card.eliminated {
opacity: 0.5;
filter: grayscale(100%);
transform: scale(0.95);
}

.player-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 20px;
padding-bottom: 15px;
border-bottom: 1px solid rgba(255, 255, 255, 0.1);
flex-wrap: wrap;
gap: 10px;
}

.player-name {
margin: 0;
font-size: 1.2rem;
color: white;
font-weight: 600;
}

.eliminated-badge {
background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
color: white;
padding: 4px 12px;
border-radius: 20px;
font-size: 12px;
font-weight: 600;
text-transform: uppercase;
}

.vote-btn {
padding: 8px 16px;
font-size: 14px;
min-width: 100px;
background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
}

.vote-btn:hover {
background: linear-gradient(135deg, #f75c4c 0%, #d0493b 100%);
}

.characteristics-grid {
display: flex;
flex-direction: column;
gap: 12px;
}

.characteristic-item {
display: flex;
justify-content: space-between;
align-items: center;
padding: 8px 0;
border-bottom: 1px solid rgba(255, 255, 255, 0.05);
flex-wrap: wrap;
gap: 5px;
}

.characteristic-item:last-child {
border-bottom: none;
}

.characteristic-label {
color: rgba(255, 255, 255, 0.7);
font-size: 14px;
font-weight: 500;
min-width: 80px;
}

.characteristic-value {
text-align: right;
flex: 1;
margin-left: 10px;
}

.revealed-value {
color: white;
font-weight: 500;
font-size: 14px;
}

.own-value {
color: #a8e6cf;
font-weight: 500;
font-size: 14px;
background: rgba(168, 230, 207, 0.1);
padding: 2px 6px;
border-radius: 4px;
}

.characteristic-preview {
color: #a8e6cf;
font-size: 12px;
opacity: 0.8;
margin-top: 4px;
font-style: italic;
}

.hidden-value {
color: rgba(255, 255, 255, 0.4);
font-style: italic;
}

.reveal-btn {
padding: 4px 12px;
font-size: 12px;
background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
}

.reveal-btn:hover {
background: linear-gradient(135deg, #4aa8eb 0%, #3990c9 100%);
transform: translateY(-1px);
box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
}

.votes-display {
margin-top: 15px;
padding: 10px;
background: rgba(231, 76, 60, 0.1);
border: 1px solid rgba(231, 76, 60, 0.3);
border-radius: 8px;
text-align: center;
color: #e74c3c;
font-weight: 600;
}

.survivor {
padding: 15px 25px;
background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
color: white;
border-radius: 12px;
font-weight: 600;
font-size: 18px;
box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);
}

@media (max-width: 768px) {
h1 { font-size: 2rem; }
.container { padding: 10px; }
}

/* Notifications */
.notification {
position: fixed;
top: 20px;
right: 20px;
padding: 20px 25px;
border-radius: 15px;
color: white;
font-weight: 600;
z-index: 1000;
min-width: 320px;
transform: translateX(400px);
transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
backdrop-filter: blur(10px);
border: 1px solid rgba(255, 255, 255, 0.1);
}

.notification.show {
transform: translateX(0);
}

.notification.success {
background: linear-gradient(135deg, rgba(46, 204, 113, 0.9) 0%, rgba(39, 174, 96, 0.9) 100%);
border-left: 4px solid #2ecc71;
}

.notification.error {
background: linear-gradient(135deg, rgba(231, 76, 60, 0.9) 0%, rgba(192, 57, 43, 0.9) 100%);
border-left: 4px solid #e74c3c;
}

.notification.info {
background: linear-gradient(135deg, rgba(106, 76, 147, 0.9) 0%, rgba(142, 68, 173, 0.9) 100%);
border-left: 4px solid #6a4c93;
}

/* Timer */
.timer-container {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: linear-gradient(135deg, rgba(26, 11, 46, 0.95) 0%, rgba(45, 27, 78, 0.95) 50%, rgba(61, 44, 95, 0.95) 100%);
backdrop-filter: blur(20px);
border-radius: 20px;
padding: 40px;
text-align: center;
z-index: 999;
border: 2px solid rgba(106, 76, 147, 0.5);
min-width: 400px;
box-shadow: 0 20px 60px rgba(106, 76, 147, 0.3);
animation: timerAppear 0.5s ease-out;
}

@keyframes timerAppear {
from {
opacity: 0;
transform: translate(-50%, -50%) scale(0.8);
}
to {
opacity: 1;
transform: translate(-50%, -50%) scale(1);
}
}

.timer-display {
font-size: 5rem;
font-weight: 700;
background: linear-gradient(135deg, #6a4c93 0%, #8e44ad 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
margin: 30px 0;
font-family: 'Courier New', monospace;
text-shadow: 0 0 20px rgba(106, 76, 147, 0.5);
animation: timerPulse 1s ease-in-out infinite alternate;
}

@keyframes timerPulse {
from {
filter: brightness(1);
}
to {
filter: brightness(1.2);
}
}

.timer-message {
font-size: 1.4rem;
margin-bottom: 20px;
color: #ffffff;
font-weight: 600;
text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.timer-skip-btn {
background: linear-gradient(135deg, #6a4c93 0%, #8e44ad 100%);
padding: 15px 30px;
border: none;
border-radius: 12px;
color: white;
font-weight: 600;
font-size: 16px;
cursor: pointer;
transition: all 0.3s ease;
box-shadow: 0 6px 20px rgba(106, 76, 147, 0.4);
margin-top: 20px;
}

.timer-skip-btn:hover {
transform: translateY(-3px);
box-shadow: 0 8px 25px rgba(106, 76, 147, 0.6);
background: linear-gradient(135deg, #7a5ca3 0%, #9e54bd 100%);
}

/* Modal styles */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.modal-content {
    background: linear-gradient(135deg, #2c1810 0%, #4a2c2a 100%);
    border-radius: 15px;
    max-width: 600px;
    width: 90%;
    max-height: 80%;
    overflow-y: auto;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.modal-header {
    padding: 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-header h2 {
    margin: 0;
    color: #ffffff;
    font-size: 1.5rem;
}

.modal-body {
    padding: 20px;
}

.modal-body h3 {
    color: #e74c3c;
    margin-top: 20px;
    margin-bottom: 10px;
    font-size: 1.2rem;
}

.modal-body h3:first-child {
    margin-top: 0;
}

.modal-body p {
    color: rgba(255, 255, 255, 0.9);
    line-height: 1.6;
    margin-bottom: 15px;
}

.modal-footer {
    padding: 20px;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    text-align: center;
}

.info-btn {
    position: fixed;
    top: 80px;
    right: 20px;
    background: rgba(44, 24, 16, 0.9);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    color: white;
    font-size: 1.5rem;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 100;
}

.info-btn:hover {
    background: rgba(74, 44, 42, 0.9);
    transform: scale(1.1);
}
</style>
</head>
<body>
<div class="status" id="status">🟡 Connecting...</div>

<div class="container">
<!-- Login Screen -->
<div id="lobby" class="screen">
<h1>Bunker Game</h1>
<div style="max-width: 400px; margin: 0 auto;">
<div class="card">
<h2 style="text-align: center; margin-bottom: 20px;">� Bunker Rooms</h2>
<input type="text" id="playerName" placeholder="Enter your name" class="input" maxlength="20">
<input type="text" id="roomId" placeholder="Room ID (leave empty for random)" class="input" maxlength="10" style="margin-top: 8px;">
<button id="joinBtn" class="btn" style="width: 100%;">Join/Create Room</button>
<button id="clearDataBtn" class="btn" style="width: 100%; margin-top: 8px; background: rgba(255,255,255,0.1); font-size: 12px;">Clear Saved Data</button>

<div id="error" class="error" style="display: none;">
Connection error!
</div>

<div style="text-align: center; margin-top: 20px; color: rgba(255,255,255,0.7); font-size: 14px;">
<p>One lobby for all players worldwide!</p>
<p>First player becomes the host</p>
</div>
</div>
</div>
</div>

<!-- Waiting Screen -->
<div id="waiting" class="screen hidden">
<h1>Global Lobby</h1>
<div class="card" style="text-align: center;">
<h2 id="waitingTitle">Players in lobby: 0/8</h2>

<div id="playersList" class="players-list"></div>

<button id="startBtn" class="btn" style="display: none;">Start Game</button>

<div style="margin-top: 20px; color: rgba(255,255,255,0.7);">
<p>Minimum 2 players to start</p>
</div>
</div>
</div>

<!-- Game Screen -->
<div id="game" class="screen hidden">
<h1>Bunker Game</h1>
<div style="display: flex; justify-content: center; gap: 30px; margin: 20px 0; font-size: 16px; color: rgba(255, 255, 255, 0.8); flex-wrap: wrap;">
<span id="roundInfo" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">Round: 1</span>
<span id="phaseInfo" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">Phase: Revealing</span>
<span id="slotsInfo" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">Bunker slots: 2</span>
</div>
<div id="statusMessage" style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 12px; color: #ffffff; font-weight: 500; backdrop-filter: blur(10px);"></div>
<div id="playersGrid" style="display: grid; gap: 20px; justify-content: center; margin: 0 auto; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); max-width: 1200px;"></div>
</div>

<!-- Game End Screen -->
<div id="gameEnd" class="screen hidden">
<h1>Game Over!</h1>
<div class="card" style="text-align: center;">
<h2>🎉 Survivors:</h2>
<div id="survivors" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin: 20px 0;"></div>
<button id="restartBtn" class="btn">New Game</button>
</div>
    </div>
</div>

<!-- Scenario Modal -->
<div id="scenarioModal" class="modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="scenarioTitle">Game Scenario</h2>
            <div id="scenarioTimer" class="timer">30</div>
        </div>
        <div class="modal-body">
            <div id="scenarioStory">
                <h3 id="storyTitle">Story</h3>
                <p id="storyDescription"></p>
            </div>
            <div id="scenarioBunker">
                <h3 id="bunkerTitle">Bunker</h3>
                <p id="bunkerDescription"></p>
            </div>
        </div>
        <div class="modal-footer">
            <button id="scenarioCloseBtn" class="btn">Start Game</button>
        </div>
    </div>
</div>

<!-- Info Button for reopening scenario -->
<button id="scenarioInfoBtn" class="info-btn" style="display: none;" title="View Scenario">📋</button>

<script>
// Game data
const professions = [
'Doctor', 'Teacher', 'Engineer', 'Chef', 'Police Officer', 'Firefighter',
'Programmer', 'Architect', 'Electrician', 'Plumber', 'Mechanic',
'Farmer', 'Veterinarian', 'Psychologist', 'Journalist', 'Artist',
'Musician', 'Actor', 'Dancer', 'Writer', 'Librarian',
'Salesperson', 'Accountant', 'Lawyer', 'Judge', 'Military Officer',
'Stripper', 'Venereologist', 'Webcam Model', 'YouTuber', 'Adult Store Clerk', 
'Drop Hunter', 'Content Creator', 'IT Specialist', 'Pilot', 'Flight Attendant', 'Driver', 'Mail Carrier', 'Security Guard'
];

const health = [
'Healthy', 'Nearsighted', 'Asthma', 'Diabetes', 'Nut Allergy',
'Hypertension', 'Arthritis', 'Migraines', 'Insomnia', 'Depression',
'Anxiety', 'Sports Injury', 'Heart Surgery', 'Prosthetic Leg',
'Hearing Aid', 'Chronic Back Pain', 'Epilepsy',
'Anemia', 'Poor Coordination', 'Chronic Fatigue'
];

const hobbies = [
'Reading', 'Sports', 'Cooking', 'Drawing', 'Music', 'Dancing',
'Photography', 'Gardening', 'Fishing', 'Hunting', 'Traveling',
'Collecting', 'Knitting', 'Chess', 'Video Games', 'Movies',
'Theater', 'Astronomy', 'Geology', 'Archaeology', 'History',
'Languages', 'Programming', 'Robotics', 'Modeling',
'Rock Climbing', 'Skydiving', 'Diving', 'Surfing', 'Yoga'
];

const phobias = [
'Arachnophobia (spiders)', 'Claustrophobia (enclosed spaces)', 
'Acrophobia (heights)', 'Aerophobia (flying)', 'Aquaphobia (water)',
'Social phobia (people)', 'Agoraphobia (open spaces)',
'Nyctophobia (darkness)', 'Ophidiophobia (snakes)', 'Cynophobia (dogs)',
'Mysophobia (dirt)', 'Hemophobia (blood)', 'Thanatophobia (death)',
'Autophobia (loneliness)', 'Phonophobia (loud sounds)',
'Pyrophobia (fire)', 'Trypophobia (holes)', 'Entomophobia (insects)',
'Meteorophobia (weather)', 'Xenophobia (strangers)'
];

const baggage = [
'Backpack with food', 'First aid kit', 'Tool set',
'Sleeping bag', 'Tent', 'Flashlight with batteries',
'Radio', 'Compass and maps', '50m rope', 'Knife',
'Lighter', 'Waterproof matches', 'Canned food', '10L water',
'Blanket', 'Spare clothes', 'Books', 'Playing cards',
'Musical instrument', 'Camera', 'Documents',
'Money', 'Jewelry', 'Family photos', 'Weapon',
'Alcohol', 'Cigarettes', 'Medicine', 'Plant seeds', 'Fishing rod'
];

const facts = [
'Served in military', 'Knows martial arts', 'Can cook',
'Speaks 3 languages', 'Has driving license', 'Can sew',
'Knows first aid', 'Can repair tech', 'Good shooter',
'Knows wilderness survival', 'Knows psychology', 'Can sing',
'Good dancer', 'Plays instrument', 'Knows history',
'Quick at math', 'Good memory', 'Knows geography',
'Can draw maps', 'Knows astronomy', 'Can predict weather',
'Good navigation', 'Can climb trees', 'Fast runner',
'Strong hands', 'Good eyesight', 'Sharp hearing', 'Senses danger',
'Persuasive', 'Good leader'
];

// Game scenarios data
const scenarios = [
    {
        title: "Nuclear Winter",
        description: "After a series of explosions in major cities, the atmosphere was filled with radioactive dust. The sun is barely visible, the temperature drops rapidly, and the snow has absorbed radiation. People hide in bunkers, as every breath on the surface means the risk of contamination."
    },
    {
        title: "Chemical Fog", 
        description: "At a secret factory, an accident released a massive cloud of toxic gases into the atmosphere. Entire regions were covered, turning streets into dead zones. The gas, heavier than air, accumulates in basements and lowlands, cutting off escape routes."
    }
];

const bunkers = [
    {
        title: "Research Bunker",
        description: "The bunker, about 180 m², consists of a central corridor with adjoining rooms: a shared sleeping area, a storage room with gas masks and filters, a recreation room with a TV and an old game console, and a small medical bay. In a separate section, there is a chemical cabinet with instruments for air analysis and a collection of reagents."
    },
    {
        title: "Living Complex Bunker",
        description: "The bunker, about 220 m², is divided into several sections: a living sector with small cabins, a common dining room with canned supplies, a technical room with generators and ventilation, and a small library filled with books and board games. In the corner, there is an improvised laboratory with dosimeters and simple reagents for testing water."
    }
];

const characteristicNames = {
profession: 'Profession',
health: 'Health',
hobbies: 'Hobbies',
phobias: 'Phobias',
baggage: 'Baggage',
facts1: 'Special Skill 1',
facts2: 'Special Skill 2',
gender: 'Gender',
age: 'Age'
};

function getRandomItem(array) {
return array[Math.floor(Math.random() * array.length)];
}

function generateRandomCharacteristics() {
return {
profession: getRandomItem(professions),
health: getRandomItem(health),
hobbies: getRandomItem(hobbies),
phobias: getRandomItem(phobias),
baggage: getRandomItem(baggage),
facts1: getRandomItem(facts),
facts2: getRandomItem(facts),
gender: getRandomItem(['Male', 'Female']),
age: Math.floor(Math.random() * 70) + 21
};
}

// Player persistence functions
function generatePlayerId() {
return 'player-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
}

function generateRoomId() {
return Math.random().toString(36).substr(2, 6).toUpperCase();
}

function savePlayerData(playerId, nickname, roomId) {
    const playerData = {
        playerId,
        nickname,
        roomId,
        timestamp: Date.now()
    };
    localStorage.setItem('bunker-player-data', JSON.stringify(playerData));
}

// Добавляем функцию для сохранения состояния игры
function saveGameStateBackup() {
    if (gameState && gameState.players && gameState.players.length > 0) {
        const backup = {
            gameState: gameState,
            currentPlayer: currentPlayer,
            timestamp: Date.now()
        };
        localStorage.setItem('bunker-game-backup', JSON.stringify(backup));
        console.log('💾 Game state backup saved');
    }
}

// Функция восстановления состояния игры
function restoreGameStateBackup() {
    try {
        const backup = localStorage.getItem('bunker-game-backup');
        if (backup) {
            const data = JSON.parse(backup);
            // Восстанавливаем только если backup свежий (не старше 10 минут)
            if (Date.now() - data.timestamp < 10 * 60 * 1000) {
                console.log('🔄 Restoring game state from backup');
                return data;
            } else {
                console.log('⏰ Backup too old, not restoring');
                localStorage.removeItem('bunker-game-backup');
            }
        }
    } catch (error) {
        console.error('❌ Error restoring backup:', error);
    }
    return null;
}function getStoredPlayerData() {
try {
const data = localStorage.getItem('bunker-player-data');
if (data) {
const parsed = JSON.parse(data);
// Check if data is not older than 24 hours
if (Date.now() - parsed.timestamp < 24 * 60 * 60 * 1000) {
return parsed;
}
}
} catch (error) {
console.error('Error reading stored player data:', error);
}
return null;
}

function clearStoredPlayerData() {
    localStorage.removeItem('bunker-player-data');
}

// Scenario functions
function getRandomScenario() {
    const story = scenarios[Math.floor(Math.random() * scenarios.length)];
    const bunker = bunkers[Math.floor(Math.random() * bunkers.length)];
    return { story, bunker };
}

function showScenario(scenario) {
    if (!elements.scenarioModal || !elements.storyTitle) {
        console.error('❌ Scenario elements not found');
        return;
    }
    
    // Don't show again if already visible
    if (elements.scenarioModal.style.display === 'flex') {
        return;
    }
    
    console.log('🎬 Showing scenario to player');
    
    elements.storyTitle.textContent = scenario.story.title;
    elements.storyDescription.textContent = scenario.story.description;
    elements.bunkerTitle.textContent = scenario.bunker.title;
    elements.bunkerDescription.textContent = scenario.bunker.description;
    
    elements.scenarioModal.style.display = 'flex';
    
    // Start 30-second timer
    let timeLeft = 30;
    elements.scenarioTimer.textContent = timeLeft;
    
    const timerInterval = setInterval(() => {
        timeLeft--;
        elements.scenarioTimer.textContent = timeLeft;
        
        if (timeLeft <= 0) {
            clearInterval(timerInterval);
            hideScenario();
        }
    }, 1000);
    
    // Store timer reference for cleanup
    elements.scenarioModal.timerInterval = timerInterval;
}

function hideScenario() {
    if (elements.scenarioModal.timerInterval) {
        clearInterval(elements.scenarioModal.timerInterval);
    }
    elements.scenarioModal.style.display = 'none';
    elements.scenarioInfoBtn.style.display = 'block';
    
    // Only host can advance to next phase
    if (gameState.phase === 'scenario' && isHost) {
        gameState.phase = 'revealing';
        gameState.currentPlayerId = gameState.players[0].id;
        
        updateCurrentGameState();
        console.log('🎮 Host advanced to revealing phase');
    }
}

function reopenScenario() {
    // Show modal without timer for quick reference
    elements.scenarioModal.style.display = 'flex';
    elements.scenarioTimer.textContent = '∞';
}// API for Vercel functions
class VercelAPI {
constructor() {
this.isOnline = false;
this.debug = true;
}

log(message) {
if (this.debug) {
console.log(`[API] ${message}`);
}
}

async init() {
this.log('🌐 Checking API...');

try {
const response = await fetch('/api/game', {
method: 'GET',
headers: { 'Content-Type': 'application/json' },
signal: AbortSignal.timeout(5000)
});

this.isOnline = response.ok;
this.log(this.isOnline ? '✅ API ready' : '❌ API unavailable');
return this.isOnline;
} catch (error) {
this.log(`❌ API error: ${error.message}`);
this.isOnline = false;
return false;
}
}

        async joinGame(playerData) {
            try {
                const response = await fetch('/api/game', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'join',
                        player: playerData,
                        roomId: playerData.roomId
                    })
                });if (response.ok) {
const result = await response.json();
this.log(`✅ Player joined. Total: ${result.players.length}`);
return result;
} else {
const error = await response.text();
throw new Error(error || 'Server error');
}
} catch (error) {
this.log(`❌ Join error: ${error.message}`);
throw error;
}
}

        async getGameState(roomId) {
            try {
                const url = roomId ? `/api/game?roomId=${encodeURIComponent(roomId)}` : '/api/game';
                const response = await fetch(url);
                if (response.ok) {
                    return await response.json();
                }
                return null;
            } catch (error) {
                this.log(`❌ Error getting state: ${error.message}`);
                return null;
            }
        }

        async updateGameState(gameState, roomId) {
            try {
                const response = await fetch('/api/game', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'update',
                        gameState: gameState,
                        roomId: roomId
                    })
                });

                return response.ok;
            } catch (error) {
                this.log(`❌ Update error: ${error.message}`);
                return false;
            }
        }
}

// Game state
let gameState = null;
let currentPlayer = null;
let isHost = false;
let hasVoted = false;
let api = null;
let syncInterval = null;
let currentTimer = null;
let timerInterval = null;

// Helper function to update game state with current room
async function updateCurrentGameState() {
    // Проверяем, что состояние игры валидно перед отправкой
    if (!gameState || !gameState.players || gameState.players.length === 0) {
        console.error('❌ Trying to update invalid game state:', gameState);
        return false;
    }
    
    const roomId = currentPlayer?.roomId || gameState?.roomId || 'default';
    console.log('🔄 Updating game state for room:', roomId, {
        phase: gameState.phase,
        players: gameState.players.length,
        currentPlayer: gameState.currentPlayerId
    });
    
    try {
        const result = await api.updateGameState(gameState, roomId);
        console.log('✅ Game state updated successfully');
        return result;
    } catch (error) {
        console.error('❌ Failed to update game state:', error);
        return false;
    }
}

// DOM elements
const elements = {
lobby: document.getElementById('lobby'),
waiting: document.getElementById('waiting'),
game: document.getElementById('game'),
gameEnd: document.getElementById('gameEnd'),
playerName: document.getElementById('playerName'),
roomId: document.getElementById('roomId'),
joinBtn: document.getElementById('joinBtn'),
clearDataBtn: document.getElementById('clearDataBtn'),
startBtn: document.getElementById('startBtn'),
restartBtn: document.getElementById('restartBtn'),
waitingTitle: document.getElementById('waitingTitle'),
playersList: document.getElementById('playersList'),
playersGrid: document.getElementById('playersGrid'),
roundInfo: document.getElementById('roundInfo'),
phaseInfo: document.getElementById('phaseInfo'),
slotsInfo: document.getElementById('slotsInfo'),
statusMessage: document.getElementById('statusMessage'),
survivors: document.getElementById('survivors'),
status: document.getElementById('status'),
error: document.getElementById('error'),
scenarioModal: document.getElementById('scenarioModal'),
scenarioTitle: document.getElementById('scenarioTitle'),
scenarioTimer: document.getElementById('scenarioTimer'),
storyTitle: document.getElementById('storyTitle'),
storyDescription: document.getElementById('storyDescription'),
bunkerTitle: document.getElementById('bunkerTitle'),
bunkerDescription: document.getElementById('bunkerDescription'),
scenarioCloseBtn: document.getElementById('scenarioCloseBtn'),
scenarioInfoBtn: document.getElementById('scenarioInfoBtn')
};

// Check if critical elements exist
const missingElements = [];
Object.keys(elements).forEach(key => {
    if (!elements[key]) {
        missingElements.push(key);
    }
});

if (missingElements.length > 0) {
    console.error('❌ Missing DOM elements:', missingElements);
}

// Initialization
document.addEventListener('DOMContentLoaded', async function() {
console.log('🎮 Bunker Game loading...');

api = new VercelAPI();
const isConnected = await api.init();

updateStatus(isConnected ? '🟢 Ready to play' : '🔴 API unavailable');

// Try to restore player nickname and room from storage
const storedData = getStoredPlayerData();
if (storedData && storedData.nickname) {
elements.playerName.value = storedData.nickname;
elements.playerName.style.backgroundColor = 'rgba(106, 76, 147, 0.2)';
elements.playerName.placeholder = 'Previously used name (click to change)';
if (storedData.roomId) {
elements.roomId.value = storedData.roomId;
elements.roomId.style.backgroundColor = 'rgba(106, 76, 147, 0.2)';
}
console.log('🔄 Restored player data:', storedData.nickname, 'Room:', storedData.roomId);
}

setupEventListeners();
showScreen('lobby');

console.log('✅ Game ready!');
});

function setupEventListeners() {
    console.log('🔗 Setting up event listeners...');
    
    elements.joinBtn.addEventListener('click', joinGame);
    elements.clearDataBtn.addEventListener('click', () => {
        clearStoredPlayerData();
        elements.playerName.value = '';
        elements.roomId.value = '';
        showNotification('Saved data cleared!', 'success');
    });
    elements.startBtn.addEventListener('click', startGame);
    elements.restartBtn.addEventListener('click', restartGame);

    // Scenario modal event listeners
    if (elements.scenarioCloseBtn) {
        elements.scenarioCloseBtn.addEventListener('click', hideScenario);
    }
    if (elements.scenarioInfoBtn) {
        elements.scenarioInfoBtn.addEventListener('click', reopenScenario);
    }

    // Close modal when clicking outside
    if (elements.scenarioModal) {
        elements.scenarioModal.addEventListener('click', (e) => {
            if (e.target === elements.scenarioModal) {
                hideScenario();
            }
        });
    }

    elements.playerName.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            joinGame();
        }
    });
}

function showScreen(screenName) {
console.log('📺 Switching to screen:', screenName);
const screens = ['lobby', 'waiting', 'game', 'gameEnd'];
screens.forEach(screen => {
if (elements[screen]) {
elements[screen].classList.add('hidden');
}
});
if (elements[screenName]) {
elements[screenName].classList.remove('hidden');
}
}

function updateStatus(message) {
elements.status.textContent = message;
elements.status.className = 'status';
if (message.includes('🔴')) {
elements.status.classList.add('offline');
} else if (message.includes('🟡')) {
elements.status.classList.add('connecting');
}
}

function showError(message) {
elements.error.textContent = message;
elements.error.style.display = 'block';
}

function hideError() {
elements.error.style.display = 'none';
}

async function joinGame() {
const name = elements.playerName.value.trim();
let roomId = elements.roomId.value.trim().toUpperCase();

hideError();
updateStatus('🟡 Connecting...');

if (!name) {
showError('Enter name!');
updateStatus('🔴 Error');
return;
}

// Generate random room ID if not provided
if (!roomId) {
roomId = generateRoomId();
elements.roomId.value = roomId;
console.log('🎲 Generated room ID:', roomId);
}

if (!api.isOnline) {
showError('API unavailable! Check connection.');
updateStatus('🔴 API unavailable');
return;
}

try {
elements.joinBtn.disabled = true;

        // Try to get stored player data
        const storedData = getStoredPlayerData();
        let playerId;
        let isReconnection = false;

        // Check if this is a genuine reconnection (same name AND same room)
        if (storedData && storedData.nickname === name && storedData.roomId === roomId) {
            // Use existing player ID only if name AND room match
            playerId = storedData.playerId;
            isReconnection = true;
            console.log('🔄 Reconnecting with existing player ID:', playerId);
        } else if (storedData && storedData.roomId === roomId) {
            // Same room but different name - try to check if player still exists in game
            console.log('🔍 Same room but different name, checking if player exists...');
            const currentGameState = await api.getGameState(roomId);
            if (currentGameState && currentGameState.players) {
                const existingPlayer = currentGameState.players.find(p => p.id === storedData.playerId);
                if (existingPlayer) {
                    playerId = storedData.playerId;
                    isReconnection = true;
                    console.log('🔄 Found existing player in game, reconnecting with stored ID:', playerId);
                } else {
                    playerId = generatePlayerId();
                    console.log('🆕 Player not found in game, creating new player ID:', playerId);
                }
            } else {
                playerId = generatePlayerId();
                console.log('🆕 No game state found, creating new player ID:', playerId);
            }
        } else {
            // Generate new player ID for new name or different room
            playerId = generatePlayerId();
            console.log('🆕 Creating new player ID:', playerId);
            
            // Show notification if player changed name/room
            if (storedData) {
                if (storedData.nickname !== name) {
                    showNotification(`Starting fresh with new name: ${name}`, 'info');
                } else if (storedData.roomId !== roomId) {
                    showNotification(`Joining new room: ${roomId}`, 'info');
                }
            }
        }

        const newPlayer = {
            id: playerId,
            name: name,
            roomId: roomId,
            characteristics: generateRandomCharacteristics(),
            revealedCharacteristics: [],
            isAlive: true,
            votesReceived: 0
        };

        // Check if name is already taken in this room (unless it's a genuine reconnection)
        if (!isReconnection) {
            const currentGameState = await api.getGameState(roomId);
            if (currentGameState && currentGameState.players.some(p => p.name === name)) {
                showError('Name already taken in this room!');
                updateStatus('🔴 Error');
                elements.joinBtn.disabled = false;
                return;
            }
        }

        // Если это переподключение, попробуем сначала получить существующее состояние
        if (isReconnection) {
            console.log('🔄 Attempting reconnection, checking existing game state...');
            const existingState = await api.getGameState(roomId);
            
            if (existingState && existingState.players && existingState.players.length > 0) {
                // Проверяем, есть ли игрок в существующем состоянии
                const existingPlayer = existingState.players.find(p => p.id === playerId || p.name === name);
                
                if (existingPlayer) {
                    console.log('✅ Found existing player in game state, reconnecting...');
                    gameState = existingState;
                    currentPlayer = existingPlayer;
                    
                    // Обновляем room ID игрока если нужно
                    if (currentPlayer.roomId !== roomId) {
                        currentPlayer.roomId = roomId;
                    }
                } else {
                    console.log('❌ Player not found in existing state, joining as new...');
                    gameState = await api.joinGame(newPlayer);
                }
            } else {
                console.log('❌ No existing game state found, joining as new...');
                gameState = await api.joinGame(newPlayer);
            }
        } else {
            // Новое подключение
            gameState = await api.joinGame(newPlayer);
        }
        
        // Если получили пустое состояние, попробуем восстановить из backup
        if (!gameState || !gameState.players || gameState.players.length === 0) {
            console.warn('⚠️ Received empty game state, trying to restore from backup');
            const backup = restoreGameStateBackup();
            if (backup && backup.gameState && backup.currentPlayer) {
                gameState = backup.gameState;
                console.log('🔄 Restored game state from backup');
            } else {
                // Если и backup не помог, показываем ошибку и прерываем
                showError('Failed to join room. Please try again.');
                updateStatus('🔴 Error');
                elements.joinBtn.disabled = false;
                return;
            }
        }
        
        // Find actual player data from server (in case of reconnection)
        if (!isReconnection || !currentPlayer) {
            const serverPlayer = gameState.players.find(p => p.id === newPlayer.id);
            currentPlayer = serverPlayer || newPlayer;
        }
        
        isHost = (gameState.hostId === currentPlayer.id);
        console.log('🎯 Player setup complete:', {
            playerId: currentPlayer.id,
            playerName: currentPlayer.name,
            isHost: isHost,
            hostId: gameState.hostId,
            isReconnection: isReconnection
        });

        // Restore voting state if in voting phase
        if (gameState.phase === 'voting' && gameState.votingResults) {
            // Check if this player already voted by checking if any vote was cast from their session
            // Since we can't perfectly track individual votes, we'll be conservative
            hasVoted = false; // Reset on reconnection to allow voting
            console.log('🗳️ Restored voting state - player can vote');
        }

        // Save player data for reconnection
        savePlayerData(currentPlayer.id, currentPlayer.name, roomId);

        // Убеждаемся, что gameState валиден перед обновлением UI
        if (!gameState || !gameState.players) {
            console.error('❌ gameState is invalid after join, cannot update UI');
            showError('Game state error. Please refresh and try again.');
            updateStatus('🔴 Error');
            elements.joinBtn.disabled = false;
            return;
        }

        // Use existing updateUI function to show correct screen based on game phase
        updateUI();

startSync();

console.log(`🎯 Successfully joined/reconnected - Phase: ${gameState.phase}, Player: ${currentPlayer.name}`);
} catch (error) {
console.error('❌ Login error:', error);
showError('Error: ' + error.message);
updateStatus('🔴 Error');
elements.joinBtn.disabled = false;
}
}

function updateWaitingScreen() {
const hostIndicator = isHost ? ' (You are host 👑)' : '';
const roomIndicator = currentPlayer?.roomId ? ` - Room: ${currentPlayer.roomId}` : '';
elements.waitingTitle.textContent = `Players in lobby: ${gameState.players.length}/8${hostIndicator}${roomIndicator}`;

elements.playersList.innerHTML = '';
gameState.players.forEach(player => {
const div = document.createElement('div');
div.className = 'player-item';

const nameSpan = document.createElement('span');
const hostIcon = player.id === gameState.hostId ? '👑 ' : '';
nameSpan.textContent = hostIcon + player.name;
div.appendChild(nameSpan);

// Host can kick other players (but not themselves)
if (isHost && player.id !== currentPlayer?.id) {
console.log('🔧 Adding kick button for player:', {
    playerName: player.name, 
    isHost: isHost, 
    currentPlayerId: currentPlayer?.id, 
    hostId: gameState.hostId
});
const kickBtn = document.createElement('button');
kickBtn.className = 'btn kick-btn';
kickBtn.textContent = '🚫';
kickBtn.title = 'Kick player';
kickBtn.onclick = () => kickPlayer(player.id);
div.appendChild(kickBtn);
}

elements.playersList.appendChild(div);
});

// Host can start game with 2+ players
if (gameState.players.length >= 2 && isHost) {
elements.startBtn.style.display = 'block';
} else {
elements.startBtn.style.display = 'none';
}
}

async function kickPlayer(playerId) {
console.log('🚫 Kick player called:', {
    playerId: playerId,
    isHost: isHost,
    currentPlayerId: currentPlayer?.id,
    hostId: gameState.hostId,
    gamePhase: gameState.phase
});

if (!isHost) {
showNotification('Only host can kick players!', 'error');
return;
}

if (gameState.phase !== 'waiting') {
showNotification('Can only kick players in lobby!', 'error');
return;
}

const playerToKick = gameState.players.find(p => p.id === playerId);
if (!playerToKick) return;

// Remove player from list
gameState.players = gameState.players.filter(p => p.id !== playerId);
gameState.lastUpdate = Date.now();

await updateCurrentGameState();
updateWaitingScreen();
showNotification(`Player ${playerToKick.name} kicked from game`, 'info');
}

async function startGame() {
    if (!isHost) {
        showNotification('Only host can start the game!', 'error');
        return;
    }

    if (gameState.players.length < 2) {
        showNotification('Minimum 2 players required to start!', 'error');
        return;
    }

    // Generate scenario first
    const scenario = getRandomScenario();
    gameState.scenario = scenario;
    
    // Set scenario phase first
    gameState.phase = 'scenario';
    gameState.round = 1;
    gameState.bunkerSlots = Math.max(1, Math.floor(gameState.players.length / 2));
    
    // Update state for all players immediately
    await updateCurrentGameState();
    
    console.log('🎬 Starting game with scenario phase');
}

function startSync() {
if (syncInterval) {
clearInterval(syncInterval);
}

syncInterval = setInterval(async () => {
    try {
        const latestState = await api.getGameState(currentPlayer?.roomId);
        
        // Защита от потери состояния игры
        if (latestState && latestState.players && latestState.players.length > 0) {
            if (latestState.lastUpdate > gameState.lastUpdate) {
                console.log('🔄 Updating game state:', {
                    phase: latestState.phase,
                    players: latestState.players.length,
                    currentPlayer: latestState.currentPlayerId
                });
                
                // Сохраняем hasVoted если мы в фазе голосования
                const wasVoting = gameState.phase === 'voting';
                const stillVoting = latestState.phase === 'voting';
                const preserveVoteStatus = wasVoting && stillVoting && hasVoted;
                
                if (preserveVoteStatus) {
                    console.log('🗳️ Preserving vote status during sync');
                }
                
                gameState = latestState;
                
                // Восстанавливаем hasVoted если нужно
                if (preserveVoteStatus) {
                    hasVoted = true;
                }
                
                // Обновляем статус хоста после получения нового состояния
                isHost = (gameState.hostId === currentPlayer?.id);
                
                updateUI();
                
                // Сохраняем backup состояния игры
                saveGameStateBackup();
                
                console.log('✅ State synchronized successfully');
            }
        } else {
            console.warn('⚠️ Received empty or invalid game state, keeping current state');
            
            // Если у нас есть валидное текущее состояние, попробуем восстановить его на сервере
            if (gameState && gameState.players && gameState.players.length > 0) {
                console.log('🔄 Attempting to restore valid game state on server...');
                try {
                    await api.updateGameState(gameState);
                    console.log('✅ Successfully restored game state on server');
                } catch (restoreError) {
                    console.error('❌ Failed to restore game state:', restoreError);
                }
            }
        }
    } catch (error) {
        console.error('❌ Sync error:', error);
    }
}, 2000);
}

function updateUI() {
    if (gameState.phase === 'waiting') {
        showScreen('waiting');
        updateWaitingScreen();
        hideTimer();
    } else if (gameState.phase === 'scenario') {
        showScreen('game');
        if (gameState.scenario) {
            showScenario(gameState.scenario);
        }
    } else if (gameState.phase === 'ended') {
        showScreen('gameEnd');
        updateSurvivors();
        hideTimer();
    } else if (['revealing', 'voting'].includes(gameState.phase)) {
        showScreen('game');
        updateGameInfo();
        updatePlayersGrid();
        updateGameStatus();
        
        // Show info button if scenario exists
        if (gameState.scenario) {
            elements.scenarioInfoBtn.style.display = 'block';
        }

        // Start timer for revealing if this is current player
        if (gameState.phase === 'revealing' && gameState.currentPlayerId) {
            const isCurrentPlayer = currentPlayer && gameState.currentPlayerId === currentPlayer.id;
            
            if (isCurrentPlayer && !document.getElementById('gameTimer')) {
                // Check if player still needs to reveal characteristics
                const player = gameState.players.find(p => p.id === currentPlayer.id);
                const revealedCount = player?.revealedCharacteristics?.length || 0;
                const maxReveals = gameState.round === 1 ? 2 : 1;
                const hasMoreToReveal = revealedCount < maxReveals;
                
                // Only start timer if player actually needs to reveal more
                if (hasMoreToReveal) {
                    console.log(`🎯 Player ${currentPlayer.name} needs to reveal more (${revealedCount}/${maxReveals})`);
                    startRevealTimer();
                } else {
                    console.log(`✅ Player ${currentPlayer.name} already revealed enough (${revealedCount}/${maxReveals})`);
                }
            }
        }
}
}

function updateGameInfo() {
elements.roundInfo.textContent = `Round: ${gameState.round}`;

const phaseNames = {
revealing: 'Revealing',
voting: 'Voting',
ended: 'Game Over'
};
elements.phaseInfo.textContent = `Phase: ${phaseNames[gameState.phase]}`;
            
            // Create container for slots and end game button
            elements.slotsInfo.innerHTML = '';
            
            const slotsText = document.createElement('span');
            slotsText.textContent = `Bunker slots: ${gameState.bunkerSlots}`;
            elements.slotsInfo.appendChild(slotsText);
            
            // Add end game button for host
            if (isHost && gameState.phase !== 'ended') {
                const endBtn = document.createElement('button');
                endBtn.className = 'btn end-game-btn';
                endBtn.textContent = '🏁 End Game';
                endBtn.title = 'Force end game (host)';
                endBtn.onclick = () => forceEndGame();
                endBtn.style.marginLeft = '15px';
                elements.slotsInfo.appendChild(endBtn);
            }
}

function updateGameStatus() {
if (!gameState || gameState === null || gameState === undefined) {
console.log('updateGameStatus: gameState is invalid, skipping update:', gameState);
return;
}

console.log('🔧 updateGameStatus - Host check:', {
    currentPlayerId: currentPlayer?.id,
    hostId: gameState.hostId,
    isHost: isHost,
    calculated_isHost: (gameState.hostId === currentPlayer?.id)
});

// Принудительно пересчитываем isHost
isHost = (gameState.hostId === currentPlayer?.id);

let message = '';
elements.statusMessage.innerHTML = ''; // Clear content

if (gameState.phase === 'revealing' && gameState.currentPlayerId) {
const currentPlayerName = gameState.players.find(p => p.id === gameState.currentPlayerId)?.name;
message = `${currentPlayerName} is revealing characteristic`;

// Add skip turn button for host
if (isHost) {
console.log('🔧 Adding skip button for host:', {
    isHost: isHost, 
    currentPlayerId: currentPlayer?.id, 
    hostId: gameState.hostId
});
const messageSpan = document.createElement('span');
messageSpan.textContent = message;
elements.statusMessage.appendChild(messageSpan);

const skipBtn = document.createElement('button');
skipBtn.className = 'btn skip-btn';
skipBtn.textContent = '⏭️ Skip Turn';
skipBtn.title = 'Skip player turn (host)';
skipBtn.onclick = () => skipCurrentTurn();
skipBtn.style.marginLeft = '15px';
elements.statusMessage.appendChild(skipBtn);
} else {
elements.statusMessage.textContent = message;
}
} else if (gameState.phase === 'voting') {
message = '🗳️ Voting! Choose who to eliminate';
                
                console.log('🔧 Voting phase - checking host status:', {
                    isHost: isHost, 
                    currentPlayerId: currentPlayer?.id, 
                    hostId: gameState.hostId
                });
                
                if (isHost) {
                    const messageSpan = document.createElement('span');
                    messageSpan.textContent = message;
                    elements.statusMessage.appendChild(messageSpan);
                    
                    const endVotingBtn = document.createElement('button');
                    endVotingBtn.className = 'btn end-voting-btn';
                    endVotingBtn.textContent = '🏁 End Voting';
                    endVotingBtn.title = 'End voting early (host)';
                    endVotingBtn.onclick = () => processVoting();
                    endVotingBtn.style.marginLeft = '15px';
                    elements.statusMessage.appendChild(endVotingBtn);
                } else {
                    elements.statusMessage.textContent = message;
                }
} else {
elements.statusMessage.textContent = message;
}
}

function updatePlayersGrid() {
elements.playersGrid.innerHTML = '';

gameState.players.forEach(player => {
const card = createPlayerCard(player);
elements.playersGrid.appendChild(card);
});
}

function createPlayerCard(player) {
const card = document.createElement('div');
card.className = `player-card ${!player.isAlive ? 'eliminated' : ''} ${gameState.currentPlayerId === player.id ? 'current-player' : ''}`;

const header = document.createElement('div');
header.className = 'player-header';

const name = document.createElement('h3');
name.className = 'player-name';
const hostIcon = player.id === gameState.hostId ? '👑 ' : '';
name.textContent = hostIcon + player.name;
header.appendChild(name);

if (!player.isAlive) {
const badge = document.createElement('span');
badge.className = 'eliminated-badge';
badge.textContent = 'Eliminated';
header.appendChild(badge);
}

if (gameState.phase === 'voting' && player.id !== currentPlayer?.id && player.isAlive && !hasVoted) {
console.log(`🗳️ Creating vote button for player ${player.name}:`, {
    phase: gameState.phase,
    playerId: player.id,
    currentPlayerId: currentPlayer?.id,
    playerAlive: player.isAlive,
    hasVoted: hasVoted
});
const voteBtn = document.createElement('button');
voteBtn.className = 'btn vote-btn';
voteBtn.textContent = 'Vote';
voteBtn.onclick = () => vote(player.id);
header.appendChild(voteBtn);
} else if (gameState.phase === 'voting') {
console.log(`❌ Not creating vote button for player ${player.name}:`, {
    phase: gameState.phase,
    playerId: player.id,
    currentPlayerId: currentPlayer?.id,
    playerAlive: player.isAlive,
    hasVoted: hasVoted,
    isSamePlayer: player.id === currentPlayer?.id
});
}

card.appendChild(header);

const charGrid = document.createElement('div');
charGrid.className = 'characteristics-grid';

Object.keys(player.characteristics || {}).forEach(char => {
const item = document.createElement('div');
item.className = 'characteristic-item';

const label = document.createElement('div');
label.className = 'characteristic-label';
label.textContent = `${characteristicNames[char]}:`;

const value = document.createElement('div');
value.className = 'characteristic-value';

// Check if this is own player or another player
const isOwnPlayer = player.id === currentPlayer?.id;
const isRevealed = player.revealedCharacteristics?.includes(char);

if (isOwnPlayer) {
// Own characteristics are always visible
if (gameState.phase === 'revealing' && gameState.currentPlayerId === player.id && !isRevealed) {
// Check how many characteristics are already revealed
const revealedCount = player.revealedCharacteristics?.length || 0;
const maxReveals = gameState.round === 1 ? 2 : 1; // 2 in first round, 1 in others
const canReveal = revealedCount < maxReveals;

if (canReveal) {
// Can reveal own characteristic
const revealBtn = document.createElement('button');
revealBtn.className = 'btn reveal-btn';
revealBtn.textContent = 'Reveal';
revealBtn.onclick = () => revealCharacteristic(char);
value.appendChild(revealBtn);

// Show preview of own characteristic
const preview = document.createElement('div');
preview.className = 'characteristic-preview';
preview.textContent = char === 'age' ? `${player.characteristics[char]} years old` : player.characteristics[char];
value.appendChild(preview);
} else {
// Reached reveal limit for this round
const revealed = document.createElement('span');
revealed.className = 'own-value';
revealed.textContent = char === 'age' ? `${player.characteristics[char]} years old` : player.characteristics[char];
value.appendChild(revealed);
}
} else {
// Show own characteristic
const revealed = document.createElement('span');
revealed.className = isRevealed ? 'revealed-value' : 'own-value';
revealed.textContent = char === 'age' ? `${player.characteristics[char]} years old` : player.characteristics[char];
value.appendChild(revealed);
}
} else {
// Other players' characteristics are only visible if revealed
if (isRevealed) {
const revealed = document.createElement('span');
revealed.className = 'revealed-value';
revealed.textContent = char === 'age' ? `${player.characteristics[char]} years old` : player.characteristics[char];
value.appendChild(revealed);
} else {
const hidden = document.createElement('span');
hidden.className = 'hidden-value';
hidden.textContent = '???';
value.appendChild(hidden);
}
}

item.appendChild(label);
item.appendChild(value);
charGrid.appendChild(item);
});

card.appendChild(charGrid);

if (player.votesReceived > 0) {
const votesDisplay = document.createElement('div');
votesDisplay.className = 'votes-display';
votesDisplay.textContent = `Votes: ${player.votesReceived}`;
card.appendChild(votesDisplay);
}

return card;
}

async function skipCurrentTurn() {
if (!isHost) {
showNotification('Only host can skip turns!', 'error');
return;
}

if (gameState.phase !== 'revealing') {
showNotification('Can only skip turns in revealing phase!', 'error');
return;
}

// Remove timer if exists
hideTimer();

const alivePlayers = gameState.players.filter(p => p.isAlive);
const currentIndex = alivePlayers.findIndex(p => p.id === gameState.currentPlayerId);
const nextIndex = (currentIndex + 1) % alivePlayers.length;

// Проверяем завершен ли раунд раскрытий
if (nextIndex === 0 && checkRoundComplete()) {
// All players revealed characteristics, proceed to voting with discussion time
showTimer(60, '🗳️ Discussion time before voting', async () => {
gameState.phase = 'voting';
gameState.currentPlayerId = null;
await api.updateGameState(gameState);
}, true); // Any player can skip
} else if (nextIndex === 0) {
// Went full circle but not all revealed enough characteristics
const maxReveals = gameState.round === 1 ? 2 : 1;
const playerWithMoreToReveal = alivePlayers.find(p => {
const revealedCount = p.revealedCharacteristics?.length || 0;
return revealedCount < maxReveals;
});
if (playerWithMoreToReveal) {
gameState.currentPlayerId = playerWithMoreToReveal.id;
} else {
showTimer(60, '🗳️ Время на обсуждение перед голосованием', async () => {
gameState.phase = 'voting';
gameState.currentPlayerId = null;
await api.updateGameState(gameState);
}, true);
}
await api.updateGameState(gameState);
} else {
gameState.currentPlayerId = alivePlayers[nextIndex].id;
await api.updateGameState(gameState);
}
}

async function revealCharacteristic(char) {
    if (!currentPlayer || gameState.currentPlayerId !== currentPlayer.id) return;

    console.log('🔍 Revealing characteristic:', char, 'for player:', currentPlayer.name);

    const player = gameState.players.find(p => p.id === currentPlayer.id);
    if (!player) {
        console.error('❌ Player not found in game state');
        return;
    }

    // Ensure revealedCharacteristics array exists
    if (!player.revealedCharacteristics) {
        player.revealedCharacteristics = [];
    }
    if (!currentPlayer.revealedCharacteristics) {
        currentPlayer.revealedCharacteristics = [];
    }

    player.revealedCharacteristics.push(char);
    currentPlayer.revealedCharacteristics.push(char);

    try {
        // Use direct API call to ensure room ID is passed correctly
        const roomId = currentPlayer.roomId || gameState.roomId || 'default';
        await api.updateGameState(gameState, roomId);
        console.log('✅ State updated after revealing characteristic');
    } catch (error) {
        console.error('❌ Error updating game state:', error);
        return;
    }

    // Show discussion timer and handle next player logic when it ends
    showTimer(60, '💬 Discussion time', async () => {
        // Check if current player can reveal more characteristics
        const currentPlayerData = gameState.players.find(p => p.id === gameState.currentPlayerId);
        const revealedCount = currentPlayerData?.revealedCharacteristics?.length || 0;
        const maxReveals = gameState.round === 1 ? 2 : 1;
        const hasMoreToReveal = revealedCount < maxReveals;

        if (hasMoreToReveal) {
            // Current player can reveal more - stay with same player
            await updateCurrentGameState();
            return;
        }

        // Current player is done revealing - move to next player
        const alivePlayers = gameState.players.filter(p => p.isAlive);
        const currentIndex = alivePlayers.findIndex(p => p.id === gameState.currentPlayerId);
        const nextIndex = (currentIndex + 1) % alivePlayers.length;

        // Check if round is complete
        if (nextIndex === 0 && checkRoundComplete()) {
            // All players revealed characteristics, move to voting
            showTimer(60, '🗳️ Время на обсуждение перед голосованием', async () => {
                gameState.phase = 'voting';
                gameState.currentPlayerId = null;
                await updateCurrentGameState();
            }, true);
        } else if (nextIndex === 0) {
            // Completed full circle but not everyone revealed enough
            // Find first player who can still reveal
            const playerWithMoreToReveal = alivePlayers.find(p => {
                const revealedCount = p.revealedCharacteristics?.length || 0;
                return revealedCount < maxReveals;
            });
            
            if (playerWithMoreToReveal) {
                gameState.currentPlayerId = playerWithMoreToReveal.id;
                await updateCurrentGameState();
            } else {
                // Everyone revealed enough, move to voting
                showTimer(60, '🗳️ Время на обсуждение перед голосованием', async () => {
                    gameState.phase = 'voting';
                    gameState.currentPlayerId = null;
                    await updateCurrentGameState();
                }, true);
            }
        } else {
            // Move to next player
            gameState.currentPlayerId = alivePlayers[nextIndex].id;
            await updateCurrentGameState();
        }
    }, true); // Allow players to skip discussion
}

async function vote(playerId) {
console.log(`🗳️ Vote function called for player ${playerId}, hasVoted: ${hasVoted}`);
if (hasVoted) {
    console.log('❌ Already voted, returning');
    return;
}

gameState.votingResults = gameState.votingResults || {};
gameState.votingResults[playerId] = (gameState.votingResults[playerId] || 0) + 1;
hasVoted = true;
console.log('✅ Vote cast successfully, hasVoted set to true');
console.log('📊 Current voting results:', gameState.votingResults);

await updateCurrentGameState();

const alivePlayers = gameState.players.filter(p => p.isAlive);
const totalVotes = Object.values(gameState.votingResults).reduce((sum, votes) => sum + votes, 0);

console.log(`🔢 Vote count check: ${totalVotes} votes cast, ${alivePlayers.length} alive players`);

if (totalVotes >= alivePlayers.length) {
console.log('✅ All players voted, processing voting in 2 seconds...');
setTimeout(async () => {
await processVoting();
}, 2000);
} else {
console.log(`⏳ Waiting for more votes: ${alivePlayers.length - totalVotes} votes remaining`);
}
}

async function processVoting() {
console.log('🗳️ Processing voting, votingResults:', gameState.votingResults);

let maxVotes = 0;
let eliminatedId = null;

Object.entries(gameState.votingResults || {}).forEach(([playerId, votes]) => {
console.log(`Player ${playerId} received ${votes} votes`);
if (votes > maxVotes) {
maxVotes = votes;
eliminatedId = playerId;
}
const player = gameState.players.find(p => p.id === playerId);
if (player) player.votesReceived = votes;
});

console.log(`🎯 Player to eliminate: ${eliminatedId} with ${maxVotes} votes`);

if (eliminatedId) {
const eliminated = gameState.players.find(p => p.id === eliminatedId);
if (eliminated) {
eliminated.isAlive = false;
console.log(`💀 Eliminated player: ${eliminated.name}`);
}

await api.updateGameState(gameState);
console.log('📤 Updated game state on server after elimination');

setTimeout(async () => {
const remaining = gameState.players.filter(p => p.isAlive);
console.log(`🎮 After elimination: ${remaining.length} players remaining, ${gameState.bunkerSlots} bunker slots`);

if (remaining.length <= gameState.bunkerSlots) {
console.log('🏁 Game should end - remaining players <= bunker slots');
await endGame();
} else {
console.log('🔄 Starting next round - more players than bunker slots');
await startNextRound();
}
}, 2000);
}
}

async function startNextRound() {
console.log('🔄 Starting next round...');
gameState.round++;
gameState.phase = 'revealing';
gameState.votingResults = {};
gameState.currentPlayerId = gameState.players.filter(p => p.isAlive)[0]?.id;
hasVoted = false;

gameState.players.forEach(p => p.votesReceived = 0);

console.log(`🎯 Next round setup: Round ${gameState.round}, First player: ${gameState.currentPlayerId}`);
await api.updateGameState(gameState);
console.log('✅ Next round state updated on server');
}

        async function forceEndGame() {
            if (!isHost) {
                showNotification('Only host can end game!', 'error');
                return;
            }

            if (gameState.phase === 'ended') {
                showNotification('Игра уже завершена!', 'error');
                return;
            }

            // Завершаем игру с текущими живыми игроками как выжившими
            hideTimer();
            await endGame();
        }

async function endGame() {
console.log('🏁 Ending game...');
gameState.phase = 'ended';
await api.updateGameState(gameState);
console.log('✅ Game ended, state updated on server');

// Clear stored player data when game ends
clearStoredPlayerData();
console.log('🧹 Cleared stored player data');

showScreen('gameEnd');
updateSurvivors();
}

function updateSurvivors() {
elements.survivors.innerHTML = '';
gameState.players.filter(p => p.isAlive).forEach(player => {
const div = document.createElement('div');
div.className = 'survivor';
const hostIcon = player.id === gameState.hostId ? '👑 ' : '';
div.textContent = hostIcon + player.name;
elements.survivors.appendChild(div);
});
}

async function restartGame() {
if (!isHost) {
showNotification('Only host can restart the game!', 'error');
return;
}

// Сбрасываем состояние игры, но оставляем игроков в лобби
gameState.phase = 'waiting';
gameState.round = 1;
gameState.currentPlayerId = null;
gameState.votingResults = {};

// Восстанавливаем всех игроков
gameState.players.forEach(player => {
player.isAlive = true;
player.votesReceived = 0;
player.revealedCharacteristics = [];
player.characteristics = generateRandomCharacteristics();
});

hasVoted = false;

await api.updateGameState(gameState);

showScreen('waiting');
updateWaitingScreen();
}

// Проверка завершения раунда раскрытий
function checkRoundComplete() {
const alivePlayers = gameState.players.filter(p => p.isAlive);
const maxReveals = gameState.round === 1 ? 2 : 1;

return alivePlayers.every(player => {
const revealedCount = player.revealedCharacteristics?.length || 0;
return revealedCount >= maxReveals;
});
}

// Таймер для раскрытия характеристики
function startRevealTimer() {
const currentPlayerName = gameState.players.find(p => p.id === gameState.currentPlayerId)?.name || 'Игрок';
showTimer(10, `🎯 ${currentPlayerName}, choose a characteristic to reveal`, () => {
// Если время вышло, автоматически раскрываем первую доступную характеристику
const player = gameState.players.find(p => p.id === currentPlayer?.id);
if (player && player.characteristics) {
const revealedChars = player.revealedCharacteristics || [];
const availableChars = Object.keys(player.characteristics).filter(char => !revealedChars.includes(char));
if (availableChars.length > 0) {
// Выбираем случайную характеристику
const randomIndex = Math.floor(Math.random() * availableChars.length);
revealCharacteristic(availableChars[randomIndex]);
}
}
}, false);
}

// Функция уведомлений
function showNotification(message, type = 'info') {
const notification = document.createElement('div');
notification.className = `notification ${type}`;
notification.textContent = message;
document.body.appendChild(notification);

setTimeout(() => {
notification.classList.add('show');
}, 100);

setTimeout(() => {
notification.classList.remove('show');
setTimeout(() => {
if (notification.parentNode) {
document.body.removeChild(notification);
}
}, 300);
}, 3000);
}

// Функции таймера
function showTimer(seconds, message, onComplete, canSkip = false) {
hideTimer(); // Скрываем предыдущий таймер если есть

const timerContainer = document.createElement('div');
timerContainer.className = 'timer-container';
timerContainer.id = 'gameTimer';

const messageEl = document.createElement('div');
messageEl.className = 'timer-message';
messageEl.textContent = message;

const displayEl = document.createElement('div');
displayEl.className = 'timer-display';
displayEl.textContent = seconds;

timerContainer.appendChild(messageEl);
timerContainer.appendChild(displayEl);

if (canSkip) {
const skipBtn = document.createElement('button');
skipBtn.className = 'timer-skip-btn';
skipBtn.textContent = 'Skip';
skipBtn.onclick = () => {
hideTimer();
if (onComplete) onComplete();
};
timerContainer.appendChild(skipBtn);
}

document.body.appendChild(timerContainer);

let timeLeft = seconds;
timerInterval = setInterval(() => {
timeLeft--;
displayEl.textContent = timeLeft;

if (timeLeft <= 0) {
hideTimer();
if (onComplete) onComplete();
}
}, 1000);
}

function hideTimer() {
if (timerInterval) {
clearInterval(timerInterval);
timerInterval = null;
}
const timer = document.getElementById('gameTimer');
if (timer) {
document.body.removeChild(timer);
}
}

// Обработка закрытия страницы
window.addEventListener('beforeunload', () => {
if (syncInterval) {
clearInterval(syncInterval);
}
if (timerInterval) {
clearInterval(timerInterval);
}
});

// Автоматический старт приложения
document.addEventListener('DOMContentLoaded', async () => {
    console.log('🎮 Bunker Game запущен!');

    setupEventListeners();
    showScreen('lobby');

    // НЕ загружаем состояние игры при старте без подключения к комнате
    // Состояние будет загружено только после подключения игрока к комнате
    console.log('� Ready to join room');
});
</script>
</body>
</html>