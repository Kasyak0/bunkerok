<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bunker Game - Online</title>

<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
background: linear-gradient(135deg, #1a0b2e 0%, #2d1b4e 50%, #3d2c5f 100%);
color: #ffffff;
min-height: 100vh;
overflow-x: hidden;
}

.container {
max-width: 1400px;
margin: 0 auto;
padding: 20px;
position: relative;
z-index: 1;
}

.screen {
min-height: 100vh;
position: relative;
}

.screen.hidden {
display: none !important;
}

.btn {
padding: 12px 24px;
border: none;
border-radius: 12px;
font-size: 16px;
font-weight: 600;
cursor: pointer;
transition: all 0.3s ease;
background: linear-gradient(135deg, #6a4c93 0%, #8e44ad 100%);
color: white;
box-shadow: 0 4px 15px rgba(106, 76, 147, 0.3);
margin: 5px;
}

.btn:hover {
transform: translateY(-2px);
box-shadow: 0 6px 20px rgba(106, 76, 147, 0.4);
background: linear-gradient(135deg, #7a5ca3 0%, #9e54bd 100%);
}

.btn:disabled {
opacity: 0.6;
cursor: not-allowed;
transform: none;
}

.card {
background: rgba(255, 255, 255, 0.05);
backdrop-filter: blur(10px);
border: 1px solid rgba(255, 255, 255, 0.1);
border-radius: 16px;
padding: 20px;
transition: all 0.3s ease;
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
margin: 15px 0;
}

h1 {
font-size: 3rem;
font-weight: 700;
text-align: center;
background: linear-gradient(135deg, #ffffff 0%, #e0c3fc 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
margin-bottom: 30px;
}

.input {
width: 100%;
padding: 12px 16px;
border: 1px solid rgba(255, 255, 255, 0.2);
border-radius: 12px;
background: rgba(255, 255, 255, 0.05);
color: white;
font-size: 16px;
transition: all 0.3s ease;
backdrop-filter: blur(10px);
margin: 10px 0;
}

.input:focus {
outline: none;
border-color: #8e44ad;
box-shadow: 0 0 0 3px rgba(142, 68, 173, 0.2);
background: rgba(255, 255, 255, 0.08);
}

.input::placeholder {
color: rgba(255, 255, 255, 0.5);
}

.status {
position: fixed;
top: 20px;
right: 20px;
padding: 8px 16px;
border-radius: 20px;
font-size: 12px;
font-weight: 600;
z-index: 1000;
background: #2ecc71;
color: white;
}

.status.offline {
background: #e74c3c;
}

.status.connecting {
background: #f39c12;
}

.error {
background: rgba(231, 76, 60, 0.1);
border: 1px solid rgba(231, 76, 60, 0.5);
color: #e74c3c;
padding: 15px;
border-radius: 12px;
margin: 20px 0;
text-align: center;
}

.players-list {
display: flex;
flex-wrap: wrap;
gap: 15px;
justify-content: center;
margin: 20px 0;
}

.player-item {
padding: 10px 20px;
background: rgba(255, 255, 255, 0.1);
border: 1px solid rgba(255, 255, 255, 0.2);
border-radius: 8px;
color: white;
font-weight: 500;
display: flex;
justify-content: space-between;
align-items: center;
}

.kick-btn {
padding: 5px 10px;
font-size: 12px;
background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
color: white;
border: none;
border-radius: 4px;
cursor: pointer;
transition: all 0.2s ease;
}

.kick-btn:hover {
background: linear-gradient(135deg, #c0392b 0%, #a93226 100%);
transform: translateY(-1px);
}

.skip-btn {
padding: 8px 16px;
font-size: 14px;
background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
color: white;
border: none;
border-radius: 6px;
cursor: pointer;
transition: all 0.2s ease;
}

.skip-btn:hover {
background: linear-gradient(135deg, #e67e22 0%, #d68910 100%);
transform: translateY(-1px);
}

        .end-game-btn {
            padding: 8px 16px;
            font-size: 14px;
            background: linear-gradient(135deg, #8e44ad 0%, #7d3c98 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .end-game-btn:hover {
            background: linear-gradient(135deg, #7d3c98 0%, #6c3483 100%);
            transform: translateY(-1px);
        }
        
/* Game Cards */
.player-card {
background: rgba(255, 255, 255, 0.05);
border: 1px solid rgba(255, 255, 255, 0.1);
border-radius: 16px;
padding: 20px;
min-height: 400px;
transition: all 0.3s ease;
}

.player-card.current-player {
border-color: #8e44ad;
box-shadow: 0 0 20px rgba(142, 68, 173, 0.3);
}

.player-card.eliminated {
opacity: 0.5;
filter: grayscale(100%);
transform: scale(0.95);
}

.player-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 20px;
padding-bottom: 15px;
border-bottom: 1px solid rgba(255, 255, 255, 0.1);
flex-wrap: wrap;
gap: 10px;
}

.player-name {
margin: 0;
font-size: 1.2rem;
color: white;
font-weight: 600;
}

.eliminated-badge {
background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
color: white;
padding: 4px 12px;
border-radius: 20px;
font-size: 12px;
font-weight: 600;
text-transform: uppercase;
}

.vote-btn {
padding: 8px 16px;
font-size: 14px;
min-width: 100px;
background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
}

.vote-btn:hover {
background: linear-gradient(135deg, #f75c4c 0%, #d0493b 100%);
}

.characteristics-grid {
display: flex;
flex-direction: column;
gap: 12px;
}

.characteristic-item {
display: flex;
justify-content: space-between;
align-items: center;
padding: 8px 0;
border-bottom: 1px solid rgba(255, 255, 255, 0.05);
flex-wrap: wrap;
gap: 5px;
}

.characteristic-item:last-child {
border-bottom: none;
}

.characteristic-label {
color: rgba(255, 255, 255, 0.7);
font-size: 14px;
font-weight: 500;
min-width: 80px;
}

.characteristic-value {
text-align: right;
flex: 1;
margin-left: 10px;
}

.revealed-value {
color: white;
font-weight: 500;
font-size: 14px;
}

.own-value {
color: #a8e6cf;
font-weight: 500;
font-size: 14px;
background: rgba(168, 230, 207, 0.1);
padding: 2px 6px;
border-radius: 4px;
}

.characteristic-preview {
color: #a8e6cf;
font-size: 12px;
opacity: 0.8;
margin-top: 4px;
font-style: italic;
}

.hidden-value {
color: rgba(255, 255, 255, 0.4);
font-style: italic;
}

.reveal-btn {
padding: 4px 12px;
font-size: 12px;
background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
}

.reveal-btn:hover {
background: linear-gradient(135deg, #4aa8eb 0%, #3990c9 100%);
transform: translateY(-1px);
box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
}

.votes-display {
margin-top: 15px;
padding: 10px;
background: rgba(231, 76, 60, 0.1);
border: 1px solid rgba(231, 76, 60, 0.3);
border-radius: 8px;
text-align: center;
color: #e74c3c;
font-weight: 600;
}

.survivor {
padding: 15px 25px;
background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
color: white;
border-radius: 12px;
font-weight: 600;
font-size: 18px;
box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);
}

@media (max-width: 768px) {
h1 { font-size: 2rem; }
.container { padding: 10px; }
}

/* Notifications */
.notification {
position: fixed;
top: 20px;
right: 20px;
padding: 20px 25px;
border-radius: 15px;
color: white;
font-weight: 600;
z-index: 1000;
min-width: 320px;
transform: translateX(400px);
transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
backdrop-filter: blur(10px);
border: 1px solid rgba(255, 255, 255, 0.1);
}

.notification.show {
transform: translateX(0);
}

.notification.success {
background: linear-gradient(135deg, rgba(46, 204, 113, 0.9) 0%, rgba(39, 174, 96, 0.9) 100%);
border-left: 4px solid #2ecc71;
}

.notification.error {
background: linear-gradient(135deg, rgba(231, 76, 60, 0.9) 0%, rgba(192, 57, 43, 0.9) 100%);
border-left: 4px solid #e74c3c;
}

.notification.info {
background: linear-gradient(135deg, rgba(106, 76, 147, 0.9) 0%, rgba(142, 68, 173, 0.9) 100%);
border-left: 4px solid #6a4c93;
}

/* Timer */
.timer-container {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: linear-gradient(135deg, rgba(26, 11, 46, 0.95) 0%, rgba(45, 27, 78, 0.95) 50%, rgba(61, 44, 95, 0.95) 100%);
backdrop-filter: blur(20px);
border-radius: 20px;
padding: 40px;
text-align: center;
z-index: 999;
border: 2px solid rgba(106, 76, 147, 0.5);
min-width: 400px;
box-shadow: 0 20px 60px rgba(106, 76, 147, 0.3);
animation: timerAppear 0.5s ease-out;
}

@keyframes timerAppear {
from {
opacity: 0;
transform: translate(-50%, -50%) scale(0.8);
}
to {
opacity: 1;
transform: translate(-50%, -50%) scale(1);
}
}

.timer-display {
font-size: 5rem;
font-weight: 700;
background: linear-gradient(135deg, #6a4c93 0%, #8e44ad 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
margin: 30px 0;
font-family: 'Courier New', monospace;
text-shadow: 0 0 20px rgba(106, 76, 147, 0.5);
animation: timerPulse 1s ease-in-out infinite alternate;
}

@keyframes timerPulse {
from {
filter: brightness(1);
}
to {
filter: brightness(1.2);
}
}

.timer-message {
font-size: 1.4rem;
margin-bottom: 20px;
color: #ffffff;
font-weight: 600;
text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.timer-skip-btn {
background: linear-gradient(135deg, #6a4c93 0%, #8e44ad 100%);
padding: 15px 30px;
border: none;
border-radius: 12px;
color: white;
font-weight: 600;
font-size: 16px;
cursor: pointer;
transition: all 0.3s ease;
box-shadow: 0 6px 20px rgba(106, 76, 147, 0.4);
margin-top: 20px;
}

.timer-skip-btn:hover {
transform: translateY(-3px);
box-shadow: 0 8px 25px rgba(106, 76, 147, 0.6);
background: linear-gradient(135deg, #7a5ca3 0%, #9e54bd 100%);
}
</style>
</head>
<body>
<div class="status" id="status">üü° Connecting...</div>

<div class="container">
<!-- Login Screen -->
<div id="lobby" class="screen">
<h1>Bunker Game</h1>
<div style="max-width: 400px; margin: 0 auto;">
<div class="card">
<h2 style="text-align: center; margin-bottom: 20px;">üåç Global Lobby</h2>
<input type="text" id="playerName" placeholder="Enter your name" class="input" maxlength="20">
<button id="joinBtn" class="btn" style="width: 100%;">Join Game</button>

<div id="error" class="error" style="display: none;">
Connection error!
</div>

<div style="text-align: center; margin-top: 20px; color: rgba(255,255,255,0.7); font-size: 14px;">
<p>One lobby for all players worldwide!</p>
<p>First player becomes the host</p>
</div>
</div>
</div>
</div>

<!-- Waiting Screen -->
<div id="waiting" class="screen hidden">
<h1>Global Lobby</h1>
<div class="card" style="text-align: center;">
<h2 id="waitingTitle">Players in lobby: 0/8</h2>

<div id="playersList" class="players-list"></div>

<button id="startBtn" class="btn" style="display: none;">Start Game</button>

<div style="margin-top: 20px; color: rgba(255,255,255,0.7);">
<p>Minimum 4 players to start</p>
</div>
</div>
</div>

<!-- Game Screen -->
<div id="game" class="screen hidden">
<h1>Bunker Game</h1>
<div style="display: flex; justify-content: center; gap: 30px; margin: 20px 0; font-size: 16px; color: rgba(255, 255, 255, 0.8); flex-wrap: wrap;">
<span id="roundInfo" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">Round: 1</span>
<span id="phaseInfo" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">Phase: Revealing</span>
<span id="slotsInfo" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">Bunker slots: 2</span>
</div>
<div id="statusMessage" style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 12px; color: #ffffff; font-weight: 500; backdrop-filter: blur(10px);"></div>
<div id="playersGrid" style="display: grid; gap: 20px; justify-content: center; margin: 0 auto; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); max-width: 1200px;"></div>
</div>

<!-- Game End Screen -->
<div id="gameEnd" class="screen hidden">
<h1>Game Over!</h1>
<div class="card" style="text-align: center;">
<h2>üéâ Survivors:</h2>
<div id="survivors" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin: 20px 0;"></div>
<button id="restartBtn" class="btn">New Game</button>
</div>
</div>
</div>

<script>
// Game data
const professions = [
'Doctor', 'Teacher', 'Engineer', 'Chef', 'Police Officer', 'Firefighter',
'Programmer', 'Architect', 'Electrician', 'Plumber', 'Mechanic',
'Farmer', 'Veterinarian', 'Psychologist', 'Journalist', 'Artist',
'Musician', 'Actor', 'Dancer', 'Writer', 'Librarian',
'Salesperson', 'Accountant', 'Lawyer', 'Judge', 'Military Officer',
'Stripper', 'Venereologist', 'Webcam Model', 'YouTuber', 'Adult Store Clerk', 
'Drop Hunter', 'Content Creator', 'IT Specialist', 'Pilot', 'Flight Attendant', 'Driver', 'Mail Carrier', 'Security Guard'
];

const health = [
'Healthy', 'Nearsighted', 'Asthma', 'Diabetes', 'Nut Allergy',
'Hypertension', 'Arthritis', 'Migraines', 'Insomnia', 'Depression',
'Anxiety', 'Sports Injury', 'Heart Surgery', 'Prosthetic Leg',
'Hearing Aid', 'Chronic Back Pain', 'Epilepsy',
'Anemia', 'Poor Coordination', 'Chronic Fatigue'
];

const hobbies = [
'Reading', 'Sports', 'Cooking', 'Drawing', 'Music', 'Dancing',
'Photography', 'Gardening', 'Fishing', 'Hunting', 'Traveling',
'Collecting', 'Knitting', 'Chess', 'Video Games', 'Movies',
'Theater', 'Astronomy', 'Geology', 'Archaeology', 'History',
'Languages', 'Programming', 'Robotics', 'Modeling',
'Rock Climbing', 'Skydiving', 'Diving', 'Surfing', 'Yoga'
];

const phobias = [
'Arachnophobia (spiders)', 'Claustrophobia (enclosed spaces)', 
'Acrophobia (heights)', 'Aerophobia (flying)', 'Aquaphobia (water)',
'Social phobia (people)', 'Agoraphobia (open spaces)',
'Nyctophobia (darkness)', 'Ophidiophobia (snakes)', 'Cynophobia (dogs)',
'Mysophobia (dirt)', 'Hemophobia (blood)', 'Thanatophobia (death)',
'Autophobia (loneliness)', 'Phonophobia (loud sounds)',
'Pyrophobia (fire)', 'Trypophobia (holes)', 'Entomophobia (insects)',
'Meteorophobia (weather)', 'Xenophobia (strangers)'
];

const baggage = [
'Backpack with food', 'First aid kit', 'Tool set',
'Sleeping bag', 'Tent', 'Flashlight with batteries',
'Radio', 'Compass and maps', '50m rope', 'Knife',
'Lighter', 'Waterproof matches', 'Canned food', '10L water',
'Blanket', 'Spare clothes', 'Books', 'Playing cards',
'Musical instrument', 'Camera', 'Documents',
'Money', 'Jewelry', 'Family photos', 'Weapon',
'Alcohol', 'Cigarettes', 'Medicine', 'Plant seeds', 'Fishing rod'
];

const facts = [
'Served in military', 'Knows martial arts', 'Can cook',
'Speaks 3 languages', 'Has driving license', 'Can sew',
'Knows first aid', 'Can repair tech', 'Good shooter',
'Knows wilderness survival', 'Knows psychology', 'Can sing',
'Good dancer', 'Plays instrument', 'Knows history',
'Quick at math', 'Good memory', 'Knows geography',
'Can draw maps', 'Knows astronomy', 'Can predict weather',
'Good navigation', 'Can climb trees', 'Fast runner',
'Strong hands', 'Good eyesight', 'Sharp hearing', 'Senses danger',
'Persuasive', 'Good leader'
];

const characteristicNames = {
profession: 'Profession',
health: 'Health',
hobbies: 'Hobbies',
phobias: 'Phobias',
baggage: 'Baggage',
facts1: 'Special Skill 1',
facts2: 'Special Skill 2',
gender: 'Gender',
age: 'Age'
};

function getRandomItem(array) {
return array[Math.floor(Math.random() * array.length)];
}

function generateRandomCharacteristics() {
return {
profession: getRandomItem(professions),
health: getRandomItem(health),
hobbies: getRandomItem(hobbies),
phobias: getRandomItem(phobias),
baggage: getRandomItem(baggage),
facts1: getRandomItem(facts),
facts2: getRandomItem(facts),
gender: getRandomItem(['Male', 'Female']),
age: Math.floor(Math.random() * 70) + 21
};
}

// API for Vercel functions
class VercelAPI {
constructor() {
this.isOnline = false;
this.debug = true;
}

log(message) {
if (this.debug) {
console.log(`[API] ${message}`);
}
}

async init() {
this.log('üåê Checking API...');

try {
const response = await fetch('/api/game', {
method: 'GET',
headers: { 'Content-Type': 'application/json' },
signal: AbortSignal.timeout(5000)
});

this.isOnline = response.ok;
this.log(this.isOnline ? '‚úÖ API ready' : '‚ùå API unavailable');
return this.isOnline;
} catch (error) {
this.log(`‚ùå API error: ${error.message}`);
this.isOnline = false;
return false;
}
}

async joinGame(playerData) {
try {
const response = await fetch('/api/game', {
method: 'POST',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify({
action: 'join',
player: playerData
})
});

if (response.ok) {
const result = await response.json();
this.log(`‚úÖ Player joined. Total: ${result.players.length}`);
return result;
} else {
const error = await response.text();
throw new Error(error || 'Server error');
}
} catch (error) {
this.log(`‚ùå Join error: ${error.message}`);
throw error;
}
}

async getGameState() {
try {
const response = await fetch('/api/game');
if (response.ok) {
return await response.json();
}
return null;
} catch (error) {
this.log(`‚ùå Error getting state: ${error.message}`);
return null;
}
}

async updateGameState(gameState) {
try {
const response = await fetch('/api/game', {
method: 'PUT',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify({
action: 'update',
gameState: gameState
})
});

return response.ok;
} catch (error) {
this.log(`‚ùå Update error: ${error.message}`);
return false;
}
}
}

// Game state
let gameState = null;
let currentPlayer = null;
let isHost = false;
let hasVoted = false;
let api = null;
let syncInterval = null;
let currentTimer = null;
let timerInterval = null;

// DOM elements
const elements = {
lobby: document.getElementById('lobby'),
waiting: document.getElementById('waiting'),
game: document.getElementById('game'),
gameEnd: document.getElementById('gameEnd'),
playerName: document.getElementById('playerName'),
joinBtn: document.getElementById('joinBtn'),
startBtn: document.getElementById('startBtn'),
restartBtn: document.getElementById('restartBtn'),
waitingTitle: document.getElementById('waitingTitle'),
playersList: document.getElementById('playersList'),
playersGrid: document.getElementById('playersGrid'),
roundInfo: document.getElementById('roundInfo'),
phaseInfo: document.getElementById('phaseInfo'),
slotsInfo: document.getElementById('slotsInfo'),
statusMessage: document.getElementById('statusMessage'),
survivors: document.getElementById('survivors'),
status: document.getElementById('status'),
error: document.getElementById('error')
};

// Initialization
document.addEventListener('DOMContentLoaded', async function() {
console.log('üéÆ Bunker Game loading...');

api = new VercelAPI();
const isConnected = await api.init();

updateStatus(isConnected ? 'üü¢ Ready to play' : 'üî¥ API unavailable');

setupEventListeners();
showScreen('lobby');

console.log('‚úÖ Game ready!');
});

function setupEventListeners() {
elements.joinBtn.addEventListener('click', joinGame);
elements.startBtn.addEventListener('click', startGame);
elements.restartBtn.addEventListener('click', restartGame);

elements.playerName.addEventListener('keypress', (e) => {
if (e.key === 'Enter') {
joinGame();
}
});
}

function showScreen(screenName) {
console.log('üì∫ Switching to screen:', screenName);
const screens = ['lobby', 'waiting', 'game', 'gameEnd'];
screens.forEach(screen => {
if (elements[screen]) {
elements[screen].classList.add('hidden');
}
});
if (elements[screenName]) {
elements[screenName].classList.remove('hidden');
}
}

function updateStatus(message) {
elements.status.textContent = message;
elements.status.className = 'status';
if (message.includes('üî¥')) {
elements.status.classList.add('offline');
} else if (message.includes('üü°')) {
elements.status.classList.add('connecting');
}
}

function showError(message) {
elements.error.textContent = message;
elements.error.style.display = 'block';
}

function hideError() {
elements.error.style.display = 'none';
}

async function joinGame() {
const name = elements.playerName.value.trim();

hideError();
updateStatus('üü° Connecting...');

if (!name) {
showError('Enter name!');
updateStatus('üî¥ Error');
return;
}

if (!api.isOnline) {
showError('API unavailable! Check connection.');
updateStatus('üî¥ API unavailable');
return;
}

try {
elements.joinBtn.disabled = true;

const newPlayer = {
id: Math.random().toString(36).substr(2, 9),
name: name,
characteristics: generateRandomCharacteristics(),
revealedCharacteristics: [],
isAlive: true,
votesReceived: 0
};

gameState = await api.joinGame(newPlayer);
currentPlayer = newPlayer;
isHost = (gameState.hostId === newPlayer.id);

showScreen('waiting');
updateWaitingScreen();
startSync();

updateStatus('üü¢ In lobby');
console.log('üéØ Successfully joined lobby');
} catch (error) {
console.error('‚ùå Login error:', error);
showError('Error: ' + error.message);
updateStatus('üî¥ Error');
elements.joinBtn.disabled = false;
}
}

function updateWaitingScreen() {
const hostIndicator = isHost ? ' (You are host üëë)' : '';
elements.waitingTitle.textContent = `Players in lobby: ${gameState.players.length}/8${hostIndicator}`;

elements.playersList.innerHTML = '';
gameState.players.forEach(player => {
const div = document.createElement('div');
div.className = 'player-item';

const nameSpan = document.createElement('span');
const hostIcon = player.id === gameState.hostId ? 'üëë ' : '';
nameSpan.textContent = hostIcon + player.name;
div.appendChild(nameSpan);

// Host can kick other players (but not themselves)
if (isHost && player.id !== currentPlayer?.id) {
const kickBtn = document.createElement('button');
kickBtn.className = 'btn kick-btn';
kickBtn.textContent = 'üö´';
kickBtn.title = 'Kick player';
kickBtn.onclick = () => kickPlayer(player.id);
div.appendChild(kickBtn);
}

elements.playersList.appendChild(div);
});

// Host can start game with 2+ players
if (gameState.players.length >= 2 && isHost) {
elements.startBtn.style.display = 'block';
} else {
elements.startBtn.style.display = 'none';
}
}

async function kickPlayer(playerId) {
if (!isHost) {
showNotification('Only host can kick players!', 'error');
return;
}

if (gameState.phase !== 'waiting') {
showNotification('Can only kick players in lobby!', 'error');
return;
}

const playerToKick = gameState.players.find(p => p.id === playerId);
if (!playerToKick) return;

// Remove player from list
gameState.players = gameState.players.filter(p => p.id !== playerId);
gameState.lastUpdate = Date.now();

await api.updateGameState(gameState);
updateWaitingScreen();
showNotification(`Player ${playerToKick.name} kicked from game`, 'info');
}

async function startGame() {
if (!isHost) {
showNotification('Only host can start the game!', 'error');
return;
}

if (gameState.players.length < 4) {
showNotification('Minimum 4 players required to start!', 'error');
return;
}

gameState.phase = 'revealing';
gameState.currentPlayerId = gameState.players[0].id;
gameState.round = 1;
gameState.bunkerSlots = Math.max(1, Math.floor(gameState.players.length / 2));

await api.updateGameState(gameState);

showScreen('game');
updateGameInfo();
updatePlayersGrid();
updateStatus();
}

function startSync() {
if (syncInterval) {
clearInterval(syncInterval);
}

syncInterval = setInterval(async () => {
try {
const latestState = await api.getGameState();
if (latestState && latestState.lastUpdate > gameState.lastUpdate) {
gameState = latestState;
updateUI();
console.log('üîÑ State synchronized');
}
} catch (error) {
console.error('‚ùå Sync error:', error);
}
}, 2000);
}

function updateUI() {
if (gameState.phase === 'waiting') {
showScreen('waiting');
updateWaitingScreen();
hideTimer();
} else if (gameState.phase === 'ended') {
showScreen('gameEnd');
updateSurvivors();
hideTimer();
} else if (['revealing', 'voting'].includes(gameState.phase)) {
showScreen('game');
updateGameInfo();
updatePlayersGrid();
updateStatus();

// Start timer for revealing if this is current player
if (gameState.phase === 'revealing' && gameState.currentPlayerId) {
const isCurrentPlayer = currentPlayer && gameState.currentPlayerId === currentPlayer.id;
if (isCurrentPlayer && !document.getElementById('gameTimer')) {
startRevealTimer();
}
}
}
}

function updateGameInfo() {
elements.roundInfo.textContent = `Round: ${gameState.round}`;

const phaseNames = {
revealing: 'Revealing',
voting: 'Voting',
ended: 'Game Over'
};
elements.phaseInfo.textContent = `Phase: ${phaseNames[gameState.phase]}`;
            
            // Create container for slots and end game button
            elements.slotsInfo.innerHTML = '';
            
            const slotsText = document.createElement('span');
            slotsText.textContent = `Bunker slots: ${gameState.bunkerSlots}`;
            elements.slotsInfo.appendChild(slotsText);
            
            // Add end game button for host
            if (isHost && gameState.phase !== 'ended') {
                const endBtn = document.createElement('button');
                endBtn.className = 'btn end-game-btn';
                endBtn.textContent = 'üèÅ End Game';
                endBtn.title = 'Force end game (host)';
                endBtn.onclick = () => forceEndGame();
                endBtn.style.marginLeft = '15px';
                elements.slotsInfo.appendChild(endBtn);
            }
}

function updateStatus() {
let message = '';
elements.statusMessage.innerHTML = ''; // Clear content

if (gameState.phase === 'revealing' && gameState.currentPlayerId) {
const currentPlayerName = gameState.players.find(p => p.id === gameState.currentPlayerId)?.name;
message = `${currentPlayerName} is revealing characteristic`;

// Add skip turn button for host
if (isHost) {
const messageSpan = document.createElement('span');
messageSpan.textContent = message;
elements.statusMessage.appendChild(messageSpan);

const skipBtn = document.createElement('button');
skipBtn.className = 'btn skip-btn';
skipBtn.textContent = '‚è≠Ô∏è Skip Turn';
skipBtn.title = 'Skip player turn (host)';
skipBtn.onclick = () => skipCurrentTurn();
skipBtn.style.marginLeft = '15px';
elements.statusMessage.appendChild(skipBtn);
} else {
elements.statusMessage.textContent = message;
}
} else if (gameState.phase === 'voting') {
message = 'üó≥Ô∏è Voting! Choose who to eliminate';
                
                if (isHost) {
                    const messageSpan = document.createElement('span');
                    messageSpan.textContent = message;
                    elements.statusMessage.appendChild(messageSpan);
                    
                    const endBtn = document.createElement('button');
                    endBtn.className = 'btn end-game-btn';
                    endBtn.textContent = 'üèÅ End Game';
                    endBtn.title = 'End game early (host)';
                    endBtn.onclick = () => forceEndGame();
                    endBtn.style.marginLeft = '15px';
                    elements.statusMessage.appendChild(endBtn);
                } else {
                    elements.statusMessage.textContent = message;
                }
} else {
elements.statusMessage.textContent = message;
}
}

function updatePlayersGrid() {
elements.playersGrid.innerHTML = '';

gameState.players.forEach(player => {
const card = createPlayerCard(player);
elements.playersGrid.appendChild(card);
});
}

function createPlayerCard(player) {
const card = document.createElement('div');
card.className = `player-card ${!player.isAlive ? 'eliminated' : ''} ${gameState.currentPlayerId === player.id ? 'current-player' : ''}`;

const header = document.createElement('div');
header.className = 'player-header';

const name = document.createElement('h3');
name.className = 'player-name';
const hostIcon = player.id === gameState.hostId ? 'üëë ' : '';
name.textContent = hostIcon + player.name;
header.appendChild(name);

if (!player.isAlive) {
const badge = document.createElement('span');
badge.className = 'eliminated-badge';
badge.textContent = 'Eliminated';
header.appendChild(badge);
}

if (gameState.phase === 'voting' && player.id !== currentPlayer?.id && player.isAlive && !hasVoted) {
const voteBtn = document.createElement('button');
voteBtn.className = 'btn vote-btn';
voteBtn.textContent = 'Vote';
voteBtn.onclick = () => vote(player.id);
header.appendChild(voteBtn);
}

card.appendChild(header);

const charGrid = document.createElement('div');
charGrid.className = 'characteristics-grid';

Object.keys(player.characteristics || {}).forEach(char => {
const item = document.createElement('div');
item.className = 'characteristic-item';

const label = document.createElement('div');
label.className = 'characteristic-label';
label.textContent = `${characteristicNames[char]}:`;

const value = document.createElement('div');
value.className = 'characteristic-value';

// Check if this is own player or another player
const isOwnPlayer = player.id === currentPlayer?.id;
const isRevealed = player.revealedCharacteristics?.includes(char);

if (isOwnPlayer) {
// Own characteristics are always visible
if (gameState.phase === 'revealing' && gameState.currentPlayerId === player.id && !isRevealed) {
// Check how many characteristics are already revealed
const revealedCount = player.revealedCharacteristics?.length || 0;
const maxReveals = gameState.round === 1 ? 2 : 1; // 2 in first round, 1 in others
const canReveal = revealedCount < maxReveals;

if (canReveal) {
// Can reveal own characteristic
const revealBtn = document.createElement('button');
revealBtn.className = 'btn reveal-btn';
revealBtn.textContent = 'Reveal';
revealBtn.onclick = () => revealCharacteristic(char);
value.appendChild(revealBtn);

// Show preview of own characteristic
const preview = document.createElement('div');
preview.className = 'characteristic-preview';
preview.textContent = char === 'age' ? `${player.characteristics[char]} years old` : player.characteristics[char];
value.appendChild(preview);
} else {
// Reached reveal limit for this round
const revealed = document.createElement('span');
revealed.className = 'own-value';
revealed.textContent = char === 'age' ? `${player.characteristics[char]} years old` : player.characteristics[char];
value.appendChild(revealed);
}
} else {
// Show own characteristic
const revealed = document.createElement('span');
revealed.className = isRevealed ? 'revealed-value' : 'own-value';
revealed.textContent = char === 'age' ? `${player.characteristics[char]} years old` : player.characteristics[char];
value.appendChild(revealed);
}
} else {
// Other players' characteristics are only visible if revealed
if (isRevealed) {
const revealed = document.createElement('span');
revealed.className = 'revealed-value';
revealed.textContent = char === 'age' ? `${player.characteristics[char]} years old` : player.characteristics[char];
value.appendChild(revealed);
} else {
const hidden = document.createElement('span');
hidden.className = 'hidden-value';
hidden.textContent = '???';
value.appendChild(hidden);
}
}

item.appendChild(label);
item.appendChild(value);
charGrid.appendChild(item);
});

card.appendChild(charGrid);

if (player.votesReceived > 0) {
const votesDisplay = document.createElement('div');
votesDisplay.className = 'votes-display';
votesDisplay.textContent = `Votes: ${player.votesReceived}`;
card.appendChild(votesDisplay);
}

return card;
}

async function skipCurrentTurn() {
if (!isHost) {
showNotification('Only host can skip turns!', 'error');
return;
}

if (gameState.phase !== 'revealing') {
showNotification('Can only skip turns in revealing phase!', 'error');
return;
}

// Remove timer if exists
hideTimer();

const alivePlayers = gameState.players.filter(p => p.isAlive);
const currentIndex = alivePlayers.findIndex(p => p.id === gameState.currentPlayerId);
const nextIndex = (currentIndex + 1) % alivePlayers.length;

// –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω –ª–∏ —Ä–∞—É–Ω–¥ —Ä–∞—Å–∫—Ä—ã—Ç–∏–π
if (nextIndex === 0 && checkRoundComplete()) {
// All players revealed characteristics, proceed to voting with discussion time
showTimer(60, 'üó≥Ô∏è Discussion time before voting', async () => {
gameState.phase = 'voting';
gameState.currentPlayerId = null;
await api.updateGameState(gameState);
}, true); // Any player can skip
} else if (nextIndex === 0) {
// Went full circle but not all revealed enough characteristics
const maxReveals = gameState.round === 1 ? 2 : 1;
const playerWithMoreToReveal = alivePlayers.find(p => {
const revealedCount = p.revealedCharacteristics?.length || 0;
return revealedCount < maxReveals;
});
if (playerWithMoreToReveal) {
gameState.currentPlayerId = playerWithMoreToReveal.id;
} else {
showTimer(60, 'üó≥Ô∏è –í—Ä–µ–º—è –Ω–∞ –æ–±—Å—É–∂–¥–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ–º', async () => {
gameState.phase = 'voting';
gameState.currentPlayerId = null;
await api.updateGameState(gameState);
}, true);
}
await api.updateGameState(gameState);
} else {
gameState.currentPlayerId = alivePlayers[nextIndex].id;
await api.updateGameState(gameState);
}
}

async function revealCharacteristic(char) {
if (!currentPlayer || gameState.currentPlayerId !== currentPlayer.id) return;

const player = gameState.players.find(p => p.id === currentPlayer.id);
if (player) {
player.revealedCharacteristics = player.revealedCharacteristics || [];
player.revealedCharacteristics.push(char);
currentPlayer.revealedCharacteristics.push(char);
}

await api.updateGameState(gameState);

// –î–∞–µ–º –º–∏–Ω—É—Ç—É –Ω–∞ —Ä–∞–∑–≥–æ–≤–æ—Ä –ø–æ—Å–ª–µ —Ä–∞—Å–∫—Ä—ã—Ç–∏—è —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
showTimer(60, 'üí¨ Discussion time', async () => {
// –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∏–≥ –ª–∏ —Ç–µ–∫—É—â–∏–π –∏–≥—Ä–æ–∫ –ª–∏–º–∏—Ç–∞ —Ä–∞—Å–∫—Ä—ã—Ç–∏–π
const currentPlayerData = gameState.players.find(p => p.id === gameState.currentPlayerId);
const revealedCount = currentPlayerData?.revealedCharacteristics?.length || 0;
const maxReveals = gameState.round === 1 ? 2 : 1;
const hasMoreToReveal = revealedCount < maxReveals;

if (hasMoreToReveal) {
// –û—Å—Ç–∞–µ–º—Å—è —Å —Ç–µ–º –∂–µ –∏–≥—Ä–æ–∫–æ–º –¥–ª—è —Ä–∞—Å–∫—Ä—ã—Ç–∏—è —Å–ª–µ–¥—É—é—â–µ–π —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
await api.updateGameState(gameState);
return;
}

// –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –∏–≥—Ä–æ–∫—É –∏–ª–∏ –∫ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—é
const alivePlayers = gameState.players.filter(p => p.isAlive);
const currentIndex = alivePlayers.findIndex(p => p.id === gameState.currentPlayerId);
const nextIndex = (currentIndex + 1) % alivePlayers.length;

// –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω –ª–∏ —Ä–∞—É–Ω–¥ —Ä–∞—Å–∫—Ä—ã—Ç–∏–π
if (nextIndex === 0 && checkRoundComplete()) {
// –í—Å–µ –∏–≥—Ä–æ–∫–∏ —Ä–∞—Å–∫—Ä—ã–ª–∏ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—é
// –ù–æ —Å–Ω–∞—á–∞–ª–∞ –¥–∞–µ–º –º–∏–Ω—É—Ç—É –Ω–∞ –æ–±—Å—É–∂–¥–µ–Ω–∏–µ
showTimer(60, 'üó≥Ô∏è –í—Ä–µ–º—è –Ω–∞ –æ–±—Å—É–∂–¥–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ–º', async () => {
gameState.phase = 'voting';
gameState.currentPlayerId = null;
await api.updateGameState(gameState);
}, true); // –õ—é–±–æ–π –∏–≥—Ä–æ–∫ –º–æ–∂–µ—Ç –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å
} else if (nextIndex === 0) {
// –ü—Ä–æ—à–ª–∏ –ø–æ–ª–Ω—ã–π –∫—Ä—É–≥, –Ω–æ –Ω–µ –≤—Å–µ —Ä–∞—Å–∫—Ä—ã–ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫
// –ù–∞—Ö–æ–¥–∏–º –ø–µ—Ä–≤–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –∫–æ—Ç–æ—Ä—ã–π –µ—â–µ –º–æ–∂–µ—Ç —Ä–∞—Å–∫—Ä—ã–≤–∞—Ç—å
const maxReveals = gameState.round === 1 ? 2 : 1;
const playerWithMoreToReveal = alivePlayers.find(p => {
const revealedCount = p.revealedCharacteristics?.length || 0;
return revealedCount < maxReveals;
});
if (playerWithMoreToReveal) {
gameState.currentPlayerId = playerWithMoreToReveal.id;
} else {
// –í—Å—ë —Ä–∞—Å–∫—Ä—ã—Ç–æ, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—é
showTimer(60, 'üó≥Ô∏è –í—Ä–µ–º—è –Ω–∞ –æ–±—Å—É–∂–¥–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ–º', async () => {
gameState.phase = 'voting';
gameState.currentPlayerId = null;
await api.updateGameState(gameState);
}, true);
}
await api.updateGameState(gameState);
} else {
gameState.currentPlayerId = alivePlayers[nextIndex].id;
await api.updateGameState(gameState);
}
}, true); // Any player can skip discussion
}

async function vote(playerId) {
if (hasVoted) return;

gameState.votingResults = gameState.votingResults || {};
gameState.votingResults[playerId] = (gameState.votingResults[playerId] || 0) + 1;
hasVoted = true;

await api.updateGameState(gameState);

const alivePlayers = gameState.players.filter(p => p.isAlive);
const totalVotes = Object.values(gameState.votingResults).reduce((sum, votes) => sum + votes, 0);

if (totalVotes >= alivePlayers.length) {
setTimeout(async () => {
await processVoting();
}, 2000);
}
}

async function processVoting() {
let maxVotes = 0;
let eliminatedId = null;

Object.entries(gameState.votingResults).forEach(([playerId, votes]) => {
if (votes > maxVotes) {
maxVotes = votes;
eliminatedId = playerId;
}
const player = gameState.players.find(p => p.id === playerId);
if (player) player.votesReceived = votes;
});

if (eliminatedId) {
const eliminated = gameState.players.find(p => p.id === eliminatedId);
if (eliminated) {
eliminated.isAlive = false;
}

await api.updateGameState(gameState);

setTimeout(async () => {
const remaining = gameState.players.filter(p => p.isAlive);

if (remaining.length <= gameState.bunkerSlots) {
await endGame();
} else {
await startNextRound();
}
}, 2000);
}
}

async function startNextRound() {
gameState.round++;
gameState.phase = 'revealing';
gameState.votingResults = {};
gameState.currentPlayerId = gameState.players.filter(p => p.isAlive)[0]?.id;
hasVoted = false;

gameState.players.forEach(p => p.votesReceived = 0);

await api.updateGameState(gameState);
}

        async function forceEndGame() {
            if (!isHost) {
                showNotification('Only host can end game!', 'error');
                return;
            }

            if (gameState.phase === 'ended') {
                showNotification('–ò–≥—Ä–∞ —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!', 'error');
                return;
            }

            // –ó–∞–≤–µ—Ä—à–∞–µ–º –∏–≥—Ä—É —Å —Ç–µ–∫—É—â–∏–º–∏ –∂–∏–≤—ã–º–∏ –∏–≥—Ä–æ–∫–∞–º–∏ –∫–∞–∫ –≤—ã–∂–∏–≤—à–∏–º–∏
            hideTimer();
            await endGame();
        }

async function endGame() {
gameState.phase = 'ended';
await api.updateGameState(gameState);

showScreen('gameEnd');
updateSurvivors();
}

function updateSurvivors() {
elements.survivors.innerHTML = '';
gameState.players.filter(p => p.isAlive).forEach(player => {
const div = document.createElement('div');
div.className = 'survivor';
const hostIcon = player.id === gameState.hostId ? 'üëë ' : '';
div.textContent = hostIcon + player.name;
elements.survivors.appendChild(div);
});
}

async function restartGame() {
if (!isHost) {
showNotification('Only host can restart the game!', 'error');
return;
}

// –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã, –Ω–æ –æ—Å—Ç–∞–≤–ª—è–µ–º –∏–≥—Ä–æ–∫–æ–≤ –≤ –ª–æ–±–±–∏
gameState.phase = 'waiting';
gameState.round = 1;
gameState.currentPlayerId = null;
gameState.votingResults = {};

// –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤
gameState.players.forEach(player => {
player.isAlive = true;
player.votesReceived = 0;
player.revealedCharacteristics = [];
player.characteristics = generateRandomCharacteristics();
});

hasVoted = false;

await api.updateGameState(gameState);

showScreen('waiting');
updateWaitingScreen();
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞—É–Ω–¥–∞ —Ä–∞—Å–∫—Ä—ã—Ç–∏–π
function checkRoundComplete() {
const alivePlayers = gameState.players.filter(p => p.isAlive);
const maxReveals = gameState.round === 1 ? 2 : 1;

return alivePlayers.every(player => {
const revealedCount = player.revealedCharacteristics?.length || 0;
return revealedCount >= maxReveals;
});
}

// –¢–∞–π–º–µ—Ä –¥–ª—è —Ä–∞—Å–∫—Ä—ã—Ç–∏—è —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
function startRevealTimer() {
const currentPlayerName = gameState.players.find(p => p.id === gameState.currentPlayerId)?.name || '–ò–≥—Ä–æ–∫';
showTimer(10, `üéØ ${currentPlayerName}, choose a characteristic to reveal`, () => {
// –ï—Å–ª–∏ –≤—Ä–µ–º—è –≤—ã—à–ª–æ, –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞—Å–∫—Ä—ã–≤–∞–µ–º –ø–µ—Ä–≤—É—é –¥–æ—Å—Ç—É–ø–Ω—É—é —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫—É
const player = gameState.players.find(p => p.id === currentPlayer?.id);
if (player && player.characteristics) {
const revealedChars = player.revealedCharacteristics || [];
const availableChars = Object.keys(player.characteristics).filter(char => !revealedChars.includes(char));
if (availableChars.length > 0) {
// –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫—É
const randomIndex = Math.floor(Math.random() * availableChars.length);
revealCharacteristic(availableChars[randomIndex]);
}
}
}, false);
}

// –§—É–Ω–∫—Ü–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
function showNotification(message, type = 'info') {
const notification = document.createElement('div');
notification.className = `notification ${type}`;
notification.textContent = message;
document.body.appendChild(notification);

setTimeout(() => {
notification.classList.add('show');
}, 100);

setTimeout(() => {
notification.classList.remove('show');
setTimeout(() => {
if (notification.parentNode) {
document.body.removeChild(notification);
}
}, 300);
}, 3000);
}

// –§—É–Ω–∫—Ü–∏–∏ —Ç–∞–π–º–µ—Ä–∞
function showTimer(seconds, message, onComplete, canSkip = false) {
hideTimer(); // –°–∫—Ä—ã–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–µ—Ä –µ—Å–ª–∏ –µ—Å—Ç—å

const timerContainer = document.createElement('div');
timerContainer.className = 'timer-container';
timerContainer.id = 'gameTimer';

const messageEl = document.createElement('div');
messageEl.className = 'timer-message';
messageEl.textContent = message;

const displayEl = document.createElement('div');
displayEl.className = 'timer-display';
displayEl.textContent = seconds;

timerContainer.appendChild(messageEl);
timerContainer.appendChild(displayEl);

if (canSkip) {
const skipBtn = document.createElement('button');
skipBtn.className = 'timer-skip-btn';
skipBtn.textContent = 'Skip';
skipBtn.onclick = () => {
hideTimer();
if (onComplete) onComplete();
};
timerContainer.appendChild(skipBtn);
}

document.body.appendChild(timerContainer);

let timeLeft = seconds;
timerInterval = setInterval(() => {
timeLeft--;
displayEl.textContent = timeLeft;

if (timeLeft <= 0) {
hideTimer();
if (onComplete) onComplete();
}
}, 1000);
}

function hideTimer() {
if (timerInterval) {
clearInterval(timerInterval);
timerInterval = null;
}
const timer = document.getElementById('gameTimer');
if (timer) {
document.body.removeChild(timer);
}
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã
window.addEventListener('beforeunload', () => {
if (syncInterval) {
clearInterval(syncInterval);
}
if (timerInterval) {
clearInterval(timerInterval);
}
});

// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Å—Ç–∞—Ä—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
document.addEventListener('DOMContentLoaded', async () => {
console.log('üéÆ Bunker Game –∑–∞–ø—É—â–µ–Ω!');

setupEventListeners();
showScreen('lobby');

// –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
try {
const state = await api.getGameState();
if (state) {
gameState = state;
console.log('üì• –ó–∞–≥—Ä—É–∂–µ–Ω–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã:', gameState);
} else {
console.log('üÜï –°–æ–∑–¥–∞–Ω–æ –Ω–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã');
}
} catch (error) {
console.error('‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:', error);
}
});
</script>
</body>
</html>