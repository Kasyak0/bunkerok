<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Игра "Бункер" - Онлайн</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1a0b2e 0%, #2d1b4e 50%, #3d2c5f 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        .screen {
            min-height: 100vh;
            position: relative;
        }
        
        .screen.hidden {
            display: none !important;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #6a4c93 0%, #8e44ad 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(106, 76, 147, 0.3);
            margin: 5px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(106, 76, 147, 0.4);
            background: linear-gradient(135deg, #7a5ca3 0%, #9e54bd 100%);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            margin: 15px 0;
        }
        
        h1 {
            font-size: 3rem;
            font-weight: 700;
            text-align: center;
            background: linear-gradient(135deg, #ffffff 0%, #e0c3fc 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
        }
        
        .input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 16px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            margin: 10px 0;
        }
        
        .input:focus {
            outline: none;
            border-color: #8e44ad;
            box-shadow: 0 0 0 3px rgba(142, 68, 173, 0.2);
            background: rgba(255, 255, 255, 0.08);
        }
        
        .input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            z-index: 1000;
            background: #2ecc71;
            color: white;
        }
        
        .status.offline {
            background: #e74c3c;
        }
        
        .status.connecting {
            background: #f39c12;
        }
        
        .error {
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid rgba(231, 76, 60, 0.5);
            color: #e74c3c;
            padding: 15px;
            border-radius: 12px;
            margin: 20px 0;
            text-align: center;
        }
        
        .players-list {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .player-item {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .kick-btn {
            padding: 5px 10px;
            font-size: 12px;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .kick-btn:hover {
            background: linear-gradient(135deg, #c0392b 0%, #a93226 100%);
            transform: translateY(-1px);
        }
        
        .skip-btn {
            padding: 8px 16px;
            font-size: 14px;
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .skip-btn:hover {
            background: linear-gradient(135deg, #e67e22 0%, #d68910 100%);
            transform: translateY(-1px);
        }
        
        .end-game-btn {
            padding: 8px 16px;
            font-size: 14px;
            background: linear-gradient(135deg, #8e44ad 0%, #7d3c98 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .end-game-btn:hover {
            background: linear-gradient(135deg, #7d3c98 0%, #6c3483 100%);
            transform: translateY(-1px);
        }
        
        /* Игровые карточки */
        .player-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            min-height: 400px;
            transition: all 0.3s ease;
        }
        
        .player-card.current-player {
            border-color: #8e44ad;
            box-shadow: 0 0 20px rgba(142, 68, 173, 0.3);
        }
        
        .player-card.eliminated {
            opacity: 0.5;
            filter: grayscale(100%);
            transform: scale(0.95);
        }
        
        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .player-name {
            margin: 0;
            font-size: 1.2rem;
            color: white;
            font-weight: 600;
        }
        
        .eliminated-badge {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .vote-btn {
            padding: 8px 16px;
            font-size: 14px;
            min-width: 100px;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }
        
        .vote-btn:hover {
            background: linear-gradient(135deg, #f75c4c 0%, #d0493b 100%);
        }
        
        .characteristics-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .characteristic-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            flex-wrap: wrap;
            gap: 5px;
        }
        
        .characteristic-item:last-child {
            border-bottom: none;
        }
        
        .characteristic-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            font-weight: 500;
            min-width: 80px;
        }
        
        .characteristic-value {
            text-align: right;
            flex: 1;
            margin-left: 10px;
        }
        
        .revealed-value {
            color: white;
            font-weight: 500;
            font-size: 14px;
        }
        
        .own-value {
            color: #a8e6cf;
            font-weight: 500;
            font-size: 14px;
            background: rgba(168, 230, 207, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .characteristic-preview {
            color: #a8e6cf;
            font-size: 12px;
            opacity: 0.8;
            margin-top: 4px;
            font-style: italic;
        }
        
        .hidden-value {
            color: rgba(255, 255, 255, 0.4);
            font-style: italic;
        }
        
        .reveal-btn {
            padding: 4px 12px;
            font-size: 12px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
        }
        
        .reveal-btn:hover {
            background: linear-gradient(135deg, #4aa8eb 0%, #3990c9 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }
        
        .votes-display {
            margin-top: 15px;
            padding: 10px;
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid rgba(231, 76, 60, 0.3);
            border-radius: 8px;
            text-align: center;
            color: #e74c3c;
            font-weight: 600;
        }
        
        .survivor {
            padding: 15px 25px;
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
            border-radius: 12px;
            font-weight: 600;
            font-size: 18px;
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);
        }
        
        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            .container { padding: 10px; }
        }

        /* Стили для уведомлений */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.info {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }

        .notification.warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .notification.error {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .notification.success {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        }

        /* Стили для таймера */
        .timer-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            z-index: 999;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .timer-display {
            font-size: 4rem;
            font-weight: 700;
            margin: 20px 0;
            color: #ffffff;
        }

        .timer-message {
            font-size: 1.2rem;
            margin-bottom: 20px;
            color: #e0c3fc;
        }

        .timer-skip-btn {
            margin-top: 15px;
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .timer-skip-btn:hover {
            background: linear-gradient(135deg, #e67e22 0%, #d68910 100%);
        }

        /* Дополнительные стили для room ID */
        .room-info {
            position: fixed;
            top: 70px;
            right: 20px;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
        }

        .room-code {
            font-weight: 700;
            color: #e0c3fc;
        }
    </style>
</head>
<body>
    <div class="status" id="status">🟡 Подключение...</div>
    
    <div class="container">
        <!-- Экран входа -->
        <div id="lobby" class="screen">
            <h1>Игра "Бункер"</h1>
            <div style="max-width: 400px; margin: 0 auto;">
                <div class="card">
                    <h2 style="text-align: center; margin-bottom: 20px;">🚪 Войти в игру</h2>
                    
                    <input type="text" id="playerName" placeholder="Введите ваше имя" class="input" maxlength="20">
                    
                    <div style="margin: 20px 0;">
                        <button id="createRoomBtn" class="btn" style="width: 100%; margin-bottom: 15px; background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);">� Создать игру</button>
                        
                        <div style="text-align: center; margin: 15px 0; color: rgba(255,255,255,0.5); position: relative;">
                            <span style="background: #1a0b2e; padding: 0 15px;">или</span>
                            <div style="position: absolute; top: 50%; left: 0; right: 0; height: 1px; background: rgba(255,255,255,0.2); z-index: -1;"></div>
                        </div>
                        
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="roomInput" placeholder="Код игры" class="input" maxlength="6" style="text-transform: uppercase; flex: 1;">
                            <button id="joinRoomBtn" class="btn" style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);">Войти</button>
                        </div>
                    </div>
                    
                    <div id="error" class="error" style="display: none;">
                        Ошибка подключения!
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px; color: rgba(255,255,255,0.7); font-size: 14px;">
                        <p>• Создайте игру и поделитесь кодом с друзьями</p>
                        <p>• Минимум 4 игрока для начала</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Экран ожидания -->
        <div id="waiting" class="screen hidden">
            <h1>Комната игры</h1>
            <div class="card" style="text-align: center;">
                <h2 id="waitingTitle">Игроков в лобби: 0/8</h2>
                
                <div id="playersList" class="players-list"></div>
                
                <button id="startBtn" class="btn" style="display: none;">Начать игру</button>
                
                <div style="margin-top: 20px; color: rgba(255,255,255,0.7);">
                    <p>Минимум 2 игрока для старта</p>
                </div>
            </div>
        </div>

        <!-- Игровой экран -->
        <div id="game" class="screen hidden">
            <h1>Игра "Бункер"</h1>
            <div style="display: flex; justify-content: center; gap: 30px; margin: 20px 0; font-size: 16px; color: rgba(255, 255, 255, 0.8); flex-wrap: wrap;">
                <span id="roundInfo" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">Раунд: 1</span>
                <span id="phaseInfo" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">Фаза: Раскрытие</span>
                <span id="slotsInfo" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">Мест в бункере: 2</span>
            </div>
            <div id="statusMessage" style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 12px; color: #ffffff; font-weight: 500; backdrop-filter: blur(10px);"></div>
            <div id="playersGrid" style="display: grid; gap: 20px; justify-content: center; margin: 0 auto; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); max-width: 1200px;"></div>
        </div>

        <!-- Экран завершения -->
        <div id="gameEnd" class="screen hidden">
            <h1>Игра окончена!</h1>
            <div class="card" style="text-align: center;">
                <h2>🎉 Выжившие:</h2>
                <div id="survivors" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin: 20px 0;"></div>
                <button id="restartBtn" class="btn">Новая игра</button>
            </div>
        </div>
    </div>

    <!-- Контейнер для уведомлений -->
    <div id="notificationContainer"></div>
    
    <!-- Таймер -->
    <div id="timerContainer" class="timer-container" style="display: none;">
        <div class="timer-message" id="timerMessage">Время на разговор</div>
        <div class="timer-display" id="timerDisplay">60</div>
        <button id="timerSkipBtn" class="btn timer-skip-btn">Пропустить</button>
    </div>

    <!-- Информация о комнате -->
    <div id="roomInfo" class="room-info" style="display: none;">
        Код комнаты: <span class="room-code" id="roomCode"></span>
    </div>

    <script>
        // Данные игры
        const professions = [
            'Врач', 'Учитель', 'Инженер', 'Повар', 'Полицейский', 'Пожарный',
            'Программист', 'Архитектор', 'Электрик', 'Сантехник', 'Механик',
            'Фермер', 'Ветеринар', 'Психолог', 'Журналист', 'Художник',
            'Музыкант', 'Актер', 'Танцор', 'Писатель', 'Библиотекарь',
            'Продавец', 'Бухгалтер', 'Юрист', 'Судья', 'Военный',
            'Стриптизер', 'Венеролог', 'Веб-кам модель', 'Ютубер', 'Продавец в секс-шопе', 
            'Дропхантер', 'Кайто Ваппер', 'КТ', 'Пилот', 'Стюардесса', 'Водитель', 'Почтальон', 'Охранник'
        ];

        const health = [
            'Здоров', 'Близорукость', 'Астма', 'Диабет', 'Аллергия на орехи',
            'Гипертония', 'Артрит', 'Мигрень', 'Бессонница', 'Депрессия',
            'Тревожность', 'Спортивная травма', 'Операция на сердце', 'Протез ноги',
            'Слуховой аппарат', 'Хронические боли в спине', 'Эпилепсия',
            'Анемия', 'Плохая координация', 'Усталость'
        ];

        const hobbies = [
            'Чтение', 'Спорт', 'Готовка', 'Рисование', 'Музыка', 'Танцы',
            'Фотография', 'Садоводство', 'Рыбалка', 'Охота', 'Путешествия',
            'Коллекционирование', 'Вязание', 'Шахматы', 'Видеоигры', 'Кино',
            'Театр', 'Астрономия', 'Геология', 'Археология', 'История',
            'Языки', 'Программирование', 'Робототехника', 'Моделирование',
            'Скалолазание', 'Парашютизм', 'Дайвинг', 'Серфинг', 'Йога'
        ];

        const phobias = [
            'Арахнофобия (пауки)', 'Клаустрофобия (замкнутые пространства)', 
            'Акрофобия (высота)', 'Аэрофобия (полеты)', 'Аквафобия (вода)',
            'Социофобия (люди)', 'Агорафобия (открытые пространства)',
            'Никтофобия (темнота)', 'Офидиофобия (змеи)', 'Кинофобия (собаки)',
            'Мизофобия (грязь)', 'Гемофобия (кровь)', 'Танатофобия (смерть)',
            'Аутофобия (одиночество)', 'Фонофобия (громкие звуки)',
            'Пирофобия (огонь)', 'Трипофобия (дырки)', 'Энтомофобия (насекомые)',
            'Метеорофобия (погода)', 'Ксенофобия (незнакомцы)'
        ];

        const baggage = [
            'Рюкзак с едой', 'Аптечка', 'Набор инструментов',
            'Спальный мешок', 'Палатка', 'Фонарик с батарейками',
            'Радио', 'Компас и карты', 'Веревка 50м', 'Нож',
            'Зажигалка', 'Водонепроницаемые спички', 'Консервы', 'Вода 10л',
            'Одеяло', 'Запасная одежда', 'Книги', 'Игральные карты',
            'Музыкальный инструмент', 'Фотоаппарат', 'Документы',
            'Деньги', 'Драгоценности', 'Семейные фото', 'Оружие',
            'Алкоголь', 'Сигареты', 'Лекарства', 'Семена растений', 'Удочка'
        ];

        const facts = [
            'Служил в армии', 'Знает боевые искусства', 'Умеет готовить',
            'Говорит на 3 языках', 'Есть водительские права', 'Умеет шить',
            'Знает первую помощь', 'Умеет чинить технику', 'Хорошо стреляет',
            'Знает выживание в дикой природе', 'Знает психологию', 'Умеет петь',
            'Хорошо танцует', 'Играет на инструменте', 'Знает историю',
            'Быстро считает', 'Хорошая память', 'Знает географию',
            'Умеет рисовать карты', 'Знает астрономию', 'Может предсказывать погоду',
            'Хорошо ориентируется', 'Умеет лазать по деревьям', 'Быстро бегает',
            'Сильные руки', 'Хорошее зрение', 'Острый слух', 'Чует опасность',
            'Умеет убеждать', 'Хороший лидер'
        ];

        const characteristicNames = {
            profession: 'Профессия',
            health: 'Здоровье',
            hobbies: 'Хобби',
            phobias: 'Фобии',
            baggage: 'Багаж',
            facts1: 'Факт 1',
            facts2: 'Факт 2',
            gender: 'Пол',
            age: 'Возраст'
        };

        function getRandomItem(array) {
            return array[Math.floor(Math.random() * array.length)];
        }

        function generateRandomCharacteristics() {
            return {
                profession: getRandomItem(professions),
                health: getRandomItem(health),
                hobbies: getRandomItem(hobbies),
                phobias: getRandomItem(phobias),
                baggage: getRandomItem(baggage),
                facts1: getRandomItem(facts),
                facts2: getRandomItem(facts),
                gender: getRandomItem(['Мужчина', 'Женщина']),
                age: Math.floor(Math.random() * 70) + 21
            };
        }

        // API для работы с Vercel функциями
        class VercelAPI {
            constructor() {
                this.isOnline = false;
                this.debug = true;
                this.roomId = null;
            }

            setRoomId(id) {
                this.roomId = id;
            }

            log(message) {
                if (this.debug) {
                    console.log(`[API] ${message}`);
                }
            }

            async init() {
                this.log('🌐 Проверка API...');
                
                try {
                    const response = await fetch('/api/game', {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        signal: AbortSignal.timeout(5000)
                    });
                    
                    this.isOnline = response.ok;
                    this.log(this.isOnline ? '✅ API готов' : '❌ API недоступен');
                } catch (error) {
                    this.log(`❌ Ошибка API: ${error.message}`);
                    this.isOnline = false;
                }
                
                // Для локального тестирования - временно считаем что API доступен
                if (!this.isOnline && window.location.hostname === 'localhost') {
                    this.isOnline = true;
                    this.log('🔧 Локальный режим для тестирования');
                }
                
                return this.isOnline;
            }

            async joinGame(playerData) {
                // Локальная симуляция для тестирования
                if (window.location.hostname === 'localhost') {
                    const existingData = localStorage.getItem(`bunker_room_${this.roomId}`) || '{"players":[],"currentPlayerId":null,"phase":"waiting","round":1,"votingResults":{},"bunkerSlots":2,"maxPlayers":8,"hostId":null,"lastUpdate":0}';
                    const roomData = JSON.parse(existingData);
                    
                    if (roomData.players.length >= roomData.maxPlayers) {
                        throw new Error('Лобби заполнено!');
                    }

                    if (roomData.players.some(p => p.name === playerData.name)) {
                        throw new Error('Имя уже занято в этой комнате!');
                    }

                    roomData.players.push(playerData);
                    
                    if (roomData.players.length === 1) {
                        roomData.hostId = playerData.id;
                    }

                    roomData.lastUpdate = Date.now();
                    localStorage.setItem(`bunker_room_${this.roomId}`, JSON.stringify(roomData));
                    this.log(`✅ Игрок присоединился локально. Всего: ${roomData.players.length}`);
                    return roomData;
                }

                try {
                    const url = this.roomId ? `/api/game?roomId=${this.roomId}` : '/api/game';
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'join',
                            player: playerData
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        this.log(`✅ Игрок присоединился. Всего: ${result.players.length}`);
                        return result;
                    } else {
                        const error = await response.text();
                        throw new Error(error || 'Ошибка сервера');
                    }
                } catch (error) {
                    this.log(`❌ Ошибка присоединения: ${error.message}`);
                    throw error;
                }
            }

            async getGameState() {
                // Локальная симуляция для тестирования
                if (window.location.hostname === 'localhost') {
                    const existingData = localStorage.getItem(`bunker_room_${this.roomId}`);
                    return existingData ? JSON.parse(existingData) : null;
                }

                try {
                    const url = this.roomId ? `/api/game?roomId=${this.roomId}` : '/api/game';
                    const response = await fetch(url);
                    if (response.ok) {
                        return await response.json();
                    }
                    return null;
                } catch (error) {
                    this.log(`❌ Ошибка получения состояния: ${error.message}`);
                    return null;
                }
            }

            async updateGameState(gameState) {
                // Локальная симуляция для тестирования
                if (window.location.hostname === 'localhost') {
                    gameState.lastUpdate = Date.now();
                    localStorage.setItem(`bunker_room_${this.roomId}`, JSON.stringify(gameState));
                    this.log('✅ Состояние обновлено локально');
                    return true;
                }

                try {
                    const url = this.roomId ? `/api/game?roomId=${this.roomId}` : '/api/game';
                    const response = await fetch(url, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'update',
                            gameState: gameState
                        })
                    });
                    
                    return response.ok;
                } catch (error) {
                    this.log(`❌ Ошибка обновления: ${error.message}`);
                    return false;
                }
            }
        }

        // Состояние игры
        let gameState = null;
        let currentPlayer = null;
        let isHost = false;
        let hasVoted = false;
        let api = null;
        let syncInterval = null;
        let timerInterval = null;
        let roomId = null;

        // Элементы DOM
        const elements = {
            lobby: document.getElementById('lobby'),
            waiting: document.getElementById('waiting'),
            game: document.getElementById('game'),
            gameEnd: document.getElementById('gameEnd'),
            playerName: document.getElementById('playerName'),
            roomInput: document.getElementById('roomInput'),
            createRoomBtn: document.getElementById('createRoomBtn'),
            joinRoomBtn: document.getElementById('joinRoomBtn'),
            roomDisplay: document.getElementById('roomDisplay'),
            roomCodeDisplay: document.getElementById('roomCodeDisplay'),
            copyRoomBtn: document.getElementById('copyRoomBtn'),
            startBtn: document.getElementById('startBtn'),
            restartBtn: document.getElementById('restartBtn'),
            waitingTitle: document.getElementById('waitingTitle'),
            playersList: document.getElementById('playersList'),
            playersGrid: document.getElementById('playersGrid'),
            roundInfo: document.getElementById('roundInfo'),
            phaseInfo: document.getElementById('phaseInfo'),
            slotsInfo: document.getElementById('slotsInfo'),
            statusMessage: document.getElementById('statusMessage'),
            survivors: document.getElementById('survivors'),
            status: document.getElementById('status'),
            error: document.getElementById('error')
        };

        // Инициализация
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('🎮 Игра "Бункер" загружается...');
            
            // Проверяем URL на наличие room ID и заполняем поле
            const urlParams = new URLSearchParams(window.location.search);
            const urlRoomId = urlParams.get('room');
            if (urlRoomId) {
                elements.roomInput.value = urlRoomId;
                roomId = urlRoomId;
                setRoomId(roomId);
                loadSavedPlayerName();
            }
            
            api = new VercelAPI();
            const isConnected = await api.init();
            
            updateStatus(isConnected ? '🟢 Готов к игре' : '🔴 API недоступен');
            
            setupEventListeners();
            showScreen('lobby');
            
            console.log('✅ Игра готова!');
        });

        // Универсальная функция обновления состояния
        async function updateGameState() {
            if (api.isOnline) {
                await api.updateGameState(gameState);
            }
            // В локальном режиме просто обновляем UI
        }

        function setupEventListeners() {
            elements.createRoomBtn.addEventListener('click', createRoom);
            elements.joinRoomBtn.addEventListener('click', joinRoom);
            elements.copyRoomBtn.addEventListener('click', copyRoomLink);
            elements.startBtn.addEventListener('click', startGame);
            elements.restartBtn.addEventListener('click', restartGame);
            
            elements.playerName.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    createRoom();
                }
            });
            
            elements.roomInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    joinRoom();
                }
            });
        }

        // Функции для уведомлений
        function showNotification(message, type = 'info', duration = 3000) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.getElementById('notificationContainer').appendChild(notification);
            
            // Показываем уведомление
            setTimeout(() => notification.classList.add('show'), 10);
            
            // Скрываем уведомление
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, duration);
        }

        // Функции для таймера
        function startTimer(duration, message, onComplete, canSkip = true) {
            const timerContainer = document.getElementById('timerContainer');
            const timerMessage = document.getElementById('timerMessage');
            const timerDisplay = document.getElementById('timerDisplay');
            const timerSkipBtn = document.getElementById('timerSkipBtn');
            
            let timeLeft = duration;
            
            timerMessage.textContent = message;
            timerDisplay.textContent = timeLeft;
            timerContainer.style.display = 'block';
            timerSkipBtn.style.display = canSkip ? 'block' : 'none';
            
            // Очищаем предыдущий таймер
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            timerInterval = setInterval(() => {
                timeLeft--;
                timerDisplay.textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    stopTimer();
                    if (onComplete) onComplete();
                }
            }, 1000);
            
            // Обработка кнопки пропуска
            timerSkipBtn.onclick = () => {
                stopTimer();
                if (onComplete) onComplete();
            };
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            document.getElementById('timerContainer').style.display = 'none';
        }

        // Функции для работы с room ID
        function generateRoomId() {
            // Простой 4-символьный код как в популярных играх
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            let result = '';
            for (let i = 0; i < 4; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function setRoomId(id) {
            roomId = id;
            document.getElementById('roomCode').textContent = id;
            document.getElementById('roomInfo').style.display = 'block';
            
            // Сохраняем в localStorage
            localStorage.setItem('bunker_room_id', id);
            if (currentPlayer) {
                localStorage.setItem(`bunker_player_${id}`, currentPlayer.name);
            }
        }

        function loadSavedPlayerName() {
            if (roomId) {
                const savedName = localStorage.getItem(`bunker_player_${roomId}`);
                if (savedName) {
                    elements.playerName.value = savedName;
                }
            }
        }

        function showScreen(screenName) {
            console.log('📺 Переключение на экран:', screenName);
            const screens = ['lobby', 'waiting', 'game', 'gameEnd'];
            screens.forEach(screen => {
                if (elements[screen]) {
                    elements[screen].classList.add('hidden');
                }
            });
            if (elements[screenName]) {
                elements[screenName].classList.remove('hidden');
            }
        }

        function updateStatus(message) {
            elements.status.textContent = message;
            elements.status.className = 'status';
            if (message.includes('🔴')) {
                elements.status.classList.add('offline');
            } else if (message.includes('🟡')) {
                elements.status.classList.add('connecting');
            }
        }

        function showError(message) {
            elements.error.textContent = message;
            elements.error.style.display = 'block';
        }

        function hideError() {
            elements.error.style.display = 'none';
        }

        async function createRoom() {
            const name = elements.playerName.value.trim();
            
            if (!name) {
                showError('Введите имя!');
                return;
            }

            try {
                elements.createRoomBtn.disabled = true;
                hideError();
                updateStatus('🟡 Создание комнаты...');
                
                roomId = generateRoomId();
                api.setRoomId(roomId);
                
                const newPlayer = {
                    id: Math.random().toString(36).substr(2, 9),
                    name: name,
                    characteristics: generateRandomCharacteristics(),
                    revealedCharacteristics: [],
                    isAlive: true,
                    votesReceived: 0
                };

                gameState = await api.joinGame(newPlayer);
                currentPlayer = newPlayer;
                isHost = (gameState.hostId === newPlayer.id);

                // Сохраняем имя игрока
                localStorage.setItem(`bunker_player_${roomId}`, name);

                // Обновляем URL
                const newUrl = new URL(window.location);
                newUrl.searchParams.set('room', roomId);
                window.history.replaceState({}, '', newUrl);

                setRoomId(roomId);
                showScreen('waiting');
                updateWaitingScreen();
                startSync();

                updateStatus('🟢 В лобби');
                showNotification(`Игра создана! Код: ${roomId}`, 'success');
                
            } catch (error) {
                console.error('❌ Ошибка:', error);
                showError(error.message);
                updateStatus('🔴 Ошибка');
            } finally {
                elements.createRoomBtn.disabled = false;
            }
        }

        async function joinRoom() {
            const name = elements.playerName.value.trim();
            const room = elements.roomInput.value.trim().toUpperCase();
            
            if (!name) {
                showError('Введите имя!');
                return;
            }

            if (!room) {
                showError('Введите код игры!');
                return;
            }

            try {
                elements.joinRoomBtn.disabled = true;
                hideError();
                updateStatus('🟡 Подключение...');
                
                roomId = room;
                api.setRoomId(roomId);
                
                const newPlayer = {
                    id: Math.random().toString(36).substr(2, 9),
                    name: name,
                    characteristics: generateRandomCharacteristics(),
                    revealedCharacteristics: [],
                    isAlive: true,
                    votesReceived: 0
                };

                gameState = await api.joinGame(newPlayer);
                currentPlayer = newPlayer;
                isHost = (gameState.hostId === newPlayer.id);

                // Сохраняем имя игрока
                localStorage.setItem(`bunker_player_${roomId}`, name);

                // Обновляем URL
                const newUrl = new URL(window.location);
                newUrl.searchParams.set('room', roomId);
                window.history.replaceState({}, '', newUrl);

                setRoomId(roomId);
                showScreen('waiting');
                updateWaitingScreen();
                startSync();

                updateStatus('🟢 В лобби');
                showNotification(`Присоединились к игре ${roomId}`, 'success');
                
            } catch (error) {
                console.error('❌ Ошибка:', error);
                showError(error.message);
                updateStatus('🔴 Ошибка');
            } finally {
                elements.joinRoomBtn.disabled = false;
            }
        }

        function updateWaitingScreen() {
            const hostIndicator = isHost ? ' (Вы - хост 👑)' : '';
            elements.waitingTitle.textContent = `Игроков в лобби: ${gameState.players.length}/8${hostIndicator}`;
            
            elements.playersList.innerHTML = '';
            gameState.players.forEach(player => {
                const div = document.createElement('div');
                div.className = 'player-item';
                
                const nameSpan = document.createElement('span');
                const hostIcon = player.id === gameState.hostId ? '👑 ' : '';
                nameSpan.textContent = hostIcon + player.name;
                div.appendChild(nameSpan);

                // Хост может кикать других игроков (но не себя)
                if (isHost && player.id !== currentPlayer?.id) {
                    const kickBtn = document.createElement('button');
                    kickBtn.className = 'btn kick-btn';
                    kickBtn.textContent = '🚫';
                    kickBtn.title = 'Исключить игрока';
                    kickBtn.onclick = () => kickPlayer(player.id);
                    div.appendChild(kickBtn);
                }

                elements.playersList.appendChild(div);
            });

            // Хост может начать игру при 2+ игроках
            if (gameState.players.length >= 4 && isHost) {
                elements.startBtn.style.display = 'block';
            } else {
                elements.startBtn.style.display = 'none';
            }
        }

        async function kickPlayer(playerId) {
            if (!isHost) {
                showNotification('Только хост может исключать игроков!', 'warning');
                return;
            }

            if (gameState.phase !== 'waiting') {
                showNotification('Можно исключать игроков только в лобби!', 'warning');
                return;
            }

            const playerToKick = gameState.players.find(p => p.id === playerId);
            if (!playerToKick) return;

            const confirmKick = confirm(`Исключить игрока ${playerToKick.name}?`);
            if (!confirmKick) return;

            // Удаляем игрока из списка
            gameState.players = gameState.players.filter(p => p.id !== playerId);
            gameState.lastUpdate = Date.now();

            await updateGameState();
            updateWaitingScreen();
        }

        async function startGame() {
            if (!isHost) {
                showNotification('Только хост может начать игру!', 'warning');
                return;
            }

            if (gameState.players.length < 4) {
                showNotification('Нужно минимум 4 игрока!', 'warning');
                return;
            }

            gameState.phase = 'revealing';
            gameState.currentPlayerId = gameState.players[0].id;
            gameState.round = 1;
            gameState.bunkerSlots = Math.max(1, Math.floor(gameState.players.length / 2));
            
            // Обновляем состояние только если API доступен
            if (api.isOnline) {
                await updateGameState();
            }
            
            showScreen('game');
            updateGameInfo();
            updatePlayersGrid();
            updateStatus();
        }

        function startSync() {
            if (syncInterval) {
                clearInterval(syncInterval);
            }
            
            syncInterval = setInterval(async () => {
                try {
                    const latestState = await api.getGameState();
                    if (latestState && latestState.lastUpdate > gameState.lastUpdate) {
                        gameState = latestState;
                        updateUI();
                        console.log('🔄 Состояние синхронизировано');
                    }
                } catch (error) {
                    console.error('❌ Ошибка синхронизации:', error);
                }
            }, 2000);
        }

        function updateUI() {
            if (gameState.phase === 'waiting') {
                showScreen('waiting');
                updateWaitingScreen();
            } else if (gameState.phase === 'ended') {
                showScreen('gameEnd');
                updateSurvivors();
            } else if (['revealing', 'voting'].includes(gameState.phase)) {
                showScreen('game');
                updateGameInfo();
                updatePlayersGrid();
                updateStatus();
            }
        }

        function updateGameInfo() {
            elements.roundInfo.textContent = `Раунд: ${gameState.round}`;
            
            const phaseNames = {
                revealing: 'Раскрытие',
                voting: 'Голосование',
                ended: 'Игра окончена'
            };
            elements.phaseInfo.textContent = `Фаза: ${phaseNames[gameState.phase]}`;
            
            // Создаем контейнер для слотов и кнопки завершения
            elements.slotsInfo.innerHTML = '';
            
            const slotsText = document.createElement('span');
            slotsText.textContent = `Мест в бункере: ${gameState.bunkerSlots}`;
            elements.slotsInfo.appendChild(slotsText);
            
            // Добавляем кнопку завершения игры для хоста
            if (isHost && gameState.phase !== 'ended') {
                const endBtn = document.createElement('button');
                endBtn.className = 'btn end-game-btn';
                endBtn.textContent = '🏁 Завершить игру';
                endBtn.title = 'Принудительно завершить игру (хост)';
                endBtn.onclick = () => forceEndGame();
                endBtn.style.marginLeft = '15px';
                elements.slotsInfo.appendChild(endBtn);
            }
        }

        function updateStatus() {
            let message = '';
            elements.statusMessage.innerHTML = ''; // Очищаем содержимое
            
            if (gameState.phase === 'revealing' && gameState.currentPlayerId) {
                const currentPlayerName = gameState.players.find(p => p.id === gameState.currentPlayerId)?.name;
                message = `${currentPlayerName} раскрывает характеристику`;
                
                // Добавляем кнопку пропуска хода для хоста
                if (isHost) {
                    const messageSpan = document.createElement('span');
                    messageSpan.textContent = message;
                    elements.statusMessage.appendChild(messageSpan);
                    
                    const skipBtn = document.createElement('button');
                    skipBtn.className = 'btn skip-btn';
                    skipBtn.textContent = '⏭️ Пропустить ход';
                    skipBtn.title = 'Пропустить ход игрока (хост)';
                    skipBtn.onclick = () => skipCurrentTurn();
                    skipBtn.style.marginLeft = '15px';
                    elements.statusMessage.appendChild(skipBtn);
                } else {
                    elements.statusMessage.textContent = message;
                }
            } else if (gameState.phase === 'voting') {
                message = '🗳️ Голосование! Выберите кого исключить';
                
                if (isHost) {
                    const messageSpan = document.createElement('span');
                    messageSpan.textContent = message;
                    elements.statusMessage.appendChild(messageSpan);
                    
                    const endBtn = document.createElement('button');
                    endBtn.className = 'btn end-game-btn';
                    endBtn.textContent = '🏁 Завершить';
                    endBtn.title = 'Завершить игру досрочно (хост)';
                    endBtn.onclick = () => forceEndGame();
                    endBtn.style.marginLeft = '15px';
                    elements.statusMessage.appendChild(endBtn);
                } else {
                    elements.statusMessage.textContent = message;
                }
            } else {
                elements.statusMessage.textContent = message;
            }
        }

        function updatePlayersGrid() {
            elements.playersGrid.innerHTML = '';
            
            gameState.players.forEach(player => {
                const card = createPlayerCard(player);
                elements.playersGrid.appendChild(card);
            });
        }

        function createPlayerCard(player) {
            const card = document.createElement('div');
            card.className = `player-card ${!player.isAlive ? 'eliminated' : ''} ${gameState.currentPlayerId === player.id ? 'current-player' : ''}`;

            const header = document.createElement('div');
            header.className = 'player-header';
            
            const name = document.createElement('h3');
            name.className = 'player-name';
            const hostIcon = player.id === gameState.hostId ? '👑 ' : '';
            name.textContent = hostIcon + player.name;
            header.appendChild(name);

            if (!player.isAlive) {
                const badge = document.createElement('span');
                badge.className = 'eliminated-badge';
                badge.textContent = 'Исключен';
                header.appendChild(badge);
            }

            if (gameState.phase === 'voting' && player.id !== currentPlayer?.id && player.isAlive && !hasVoted) {
                const voteBtn = document.createElement('button');
                voteBtn.className = 'btn vote-btn';
                voteBtn.textContent = 'Голосовать';
                voteBtn.onclick = () => vote(player.id);
                header.appendChild(voteBtn);
            }

            card.appendChild(header);

            const charGrid = document.createElement('div');
            charGrid.className = 'characteristics-grid';

            Object.keys(player.characteristics || {}).forEach(char => {
                const item = document.createElement('div');
                item.className = 'characteristic-item';

                const label = document.createElement('div');
                label.className = 'characteristic-label';
                label.textContent = `${characteristicNames[char]}:`;

                const value = document.createElement('div');
                value.className = 'characteristic-value';

                // Проверяем - это свой игрок или чужой
                const isOwnPlayer = player.id === currentPlayer?.id;
                const isRevealed = player.revealedCharacteristics?.includes(char);

                if (isOwnPlayer) {
                    // Свои характеристики видим всегда
                    if (gameState.phase === 'revealing' && gameState.currentPlayerId === player.id && !isRevealed) {
                        // Можем раскрыть свою характеристику
                        const revealBtn = document.createElement('button');
                        revealBtn.className = 'btn reveal-btn';
                        revealBtn.textContent = 'Раскрыть';
                        revealBtn.onclick = () => revealCharacteristic(char);
                        value.appendChild(revealBtn);
                        
                        // Показываем превью своей характеристики
                        const preview = document.createElement('div');
                        preview.className = 'characteristic-preview';
                        preview.textContent = char === 'age' ? `${player.characteristics[char]} лет` : player.characteristics[char];
                        value.appendChild(preview);
                    } else {
                        // Показываем свою характеристику
                        const revealed = document.createElement('span');
                        revealed.className = isRevealed ? 'revealed-value' : 'own-value';
                        revealed.textContent = char === 'age' ? `${player.characteristics[char]} лет` : player.characteristics[char];
                        value.appendChild(revealed);
                    }
                } else {
                    // Чужие характеристики видим только если раскрыты
                    if (isRevealed) {
                        const revealed = document.createElement('span');
                        revealed.className = 'revealed-value';
                        revealed.textContent = char === 'age' ? `${player.characteristics[char]} лет` : player.characteristics[char];
                        value.appendChild(revealed);
                    } else {
                        const hidden = document.createElement('span');
                        hidden.className = 'hidden-value';
                        hidden.textContent = '???';
                        value.appendChild(hidden);
                    }
                }

                item.appendChild(label);
                item.appendChild(value);
                charGrid.appendChild(item);
            });

            card.appendChild(charGrid);

            if (player.votesReceived > 0) {
                const votesDisplay = document.createElement('div');
                votesDisplay.className = 'votes-display';
                votesDisplay.textContent = `Голосов: ${player.votesReceived}`;
                card.appendChild(votesDisplay);
            }

            return card;
        }

        async function skipCurrentTurn() {
            if (!isHost) {
                showNotification('Только хост может пропускать ходы!', 'warning');
                return;
            }

            if (gameState.phase !== 'revealing') {
                showNotification('Пропускать ходы можно только в фазе раскрытия!', 'warning');
                return;
            }

            const confirmSkip = confirm('Пропустить ход текущего игрока?');
            if (!confirmSkip) return;

            const alivePlayers = gameState.players.filter(p => p.isAlive);
            const currentIndex = alivePlayers.findIndex(p => p.id === gameState.currentPlayerId);
            const nextIndex = (currentIndex + 1) % alivePlayers.length;

            if (nextIndex === 0) {
                gameState.phase = 'voting';
                gameState.currentPlayerId = null;
            } else {
                gameState.currentPlayerId = alivePlayers[nextIndex].id;
            }

            await api.updateGameState(gameState);
        }

        async function revealCharacteristic(char) {
            if (!currentPlayer || gameState.currentPlayerId !== currentPlayer.id) return;

            const player = gameState.players.find(p => p.id === currentPlayer.id);
            if (player) {
                player.revealedCharacteristics = player.revealedCharacteristics || [];
                player.revealedCharacteristics.push(char);
                currentPlayer.revealedCharacteristics.push(char);
            }

            await api.updateGameState(gameState);

            // Даем 10 секунд на то, чтобы все увидели раскрытую характеристику
            showNotification('Характеристика раскрыта! Начинается время для разговора', 'success');
            
            setTimeout(() => {
                // Затем 60 секунд на разговор
                startTimer(60, 'Время для разговора', async () => {
                    await moveToNextPlayer();
                }, true);
            }, 10000);
        }

        async function moveToNextPlayer() {
            const alivePlayers = gameState.players.filter(p => p.isAlive);
            const currentIndex = alivePlayers.findIndex(p => p.id === gameState.currentPlayerId);
            const nextIndex = (currentIndex + 1) % alivePlayers.length;

            if (nextIndex === 0) {
                // Раунд завершен, начинаем минуту разговора перед голосованием
                startTimer(60, 'Общее обсуждение перед голосованием', async () => {
                    gameState.phase = 'voting';
                    gameState.currentPlayerId = null;
                    await api.updateGameState(gameState);
                }, true);
            } else {
                gameState.currentPlayerId = alivePlayers[nextIndex].id;
                await api.updateGameState(gameState);
            }
        }

        async function vote(playerId) {
            if (hasVoted) return;

            gameState.votingResults = gameState.votingResults || {};
            gameState.votingResults[playerId] = (gameState.votingResults[playerId] || 0) + 1;
            hasVoted = true;
            
            await api.updateGameState(gameState);

            const alivePlayers = gameState.players.filter(p => p.isAlive);
            const totalVotes = Object.values(gameState.votingResults).reduce((sum, votes) => sum + votes, 0);
            
            if (totalVotes >= alivePlayers.length) {
                setTimeout(async () => {
                    await processVoting();
                }, 2000);
            }
        }

        async function processVoting() {
            let maxVotes = 0;
            let eliminatedId = null;

            Object.entries(gameState.votingResults).forEach(([playerId, votes]) => {
                if (votes > maxVotes) {
                    maxVotes = votes;
                    eliminatedId = playerId;
                }
                const player = gameState.players.find(p => p.id === playerId);
                if (player) player.votesReceived = votes;
            });

            if (eliminatedId) {
                const eliminated = gameState.players.find(p => p.id === eliminatedId);
                if (eliminated) {
                    eliminated.isAlive = false;
                }

                await api.updateGameState(gameState);

                setTimeout(async () => {
                    const remaining = gameState.players.filter(p => p.isAlive);
                    
                    if (remaining.length <= gameState.bunkerSlots) {
                        await endGame();
                    } else {
                        await startNextRound();
                    }
                }, 2000);
            }
        }

        async function startNextRound() {
            gameState.round++;
            gameState.phase = 'revealing';
            gameState.votingResults = {};
            gameState.currentPlayerId = gameState.players.filter(p => p.isAlive)[0]?.id;
            hasVoted = false;

            gameState.players.forEach(p => p.votesReceived = 0);

            await api.updateGameState(gameState);
        }

        async function forceEndGame() {
            if (!isHost) {
                showNotification('Только хост может завершить игру!', 'warning');
                return;
            }

            if (gameState.phase === 'ended') {
                showNotification('Игра уже завершена!', 'info');
                return;
            }

            const confirmEnd = confirm('Принудительно завершить игру? Все живые игроки станут выжившими.');
            if (!confirmEnd) return;

            // Завершаем игру с текущими живыми игроками как выжившими
            await endGame();
        }

        async function endGame() {
            gameState.phase = 'ended';
            await api.updateGameState(gameState);
            
            showScreen('gameEnd');
            updateSurvivors();
        }

        function updateSurvivors() {
            elements.survivors.innerHTML = '';
            gameState.players.filter(p => p.isAlive).forEach(player => {
                const div = document.createElement('div');
                div.className = 'survivor';
                const hostIcon = player.id === gameState.hostId ? '👑 ' : '';
                div.textContent = hostIcon + player.name;
                elements.survivors.appendChild(div);
            });
        }

        async function restartGame() {
            if (!isHost) {
                showNotification('Только хост может перезапустить игру!', 'warning');
                return;
            }

            // Сбрасываем состояние игры, но оставляем игроков в лобби
            gameState.phase = 'waiting';
            gameState.round = 1;
            gameState.currentPlayerId = null;
            gameState.votingResults = {};
            
            // Восстанавливаем всех игроков
            gameState.players.forEach(player => {
                player.isAlive = true;
                player.votesReceived = 0;
                player.revealedCharacteristics = [];
                player.characteristics = generateRandomCharacteristics();
            });

            hasVoted = false;
            
            await api.updateGameState(gameState);

            showScreen('waiting');
            updateWaitingScreen();
        }

        // Обработка закрытия страницы
        window.addEventListener('beforeunload', () => {
            if (syncInterval) {
                clearInterval(syncInterval);
            }
            if (timerInterval) {
                clearInterval(timerInterval);
            }
        });
    </script>
</body>
</html>
