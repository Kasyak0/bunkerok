<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bunker Game - Online</title>

<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
background: linear-gradient(135deg, #1a0b2e 0%, #2d1b4e 50%, #3d2c5f 100%);
color: #ffffff;
min-height: 100vh;
overflow-x: hidden;
}

.container {
max-width: 1400px;
margin: 0 auto;
padding: 20px;
position: relative;
z-index: 1;
}

.screen {
min-height: 100vh;
position: relative;
}

.screen.hidden {
display: none !important;
}

.btn {
padding: 12px 24px;
border: none;
border-radius: 12px;
font-size: 16px;
font-weight: 600;
cursor: pointer;
transition: all 0.3s ease;
background: linear-gradient(135deg, #6a4c93 0%, #8e44ad 100%);
color: white;
box-shadow: 0 4px 15px rgba(106, 76, 147, 0.3);
margin: 5px;
}

.btn:hover {
transform: translateY(-2px);
box-shadow: 0 6px 20px rgba(106, 76, 147, 0.4);
background: linear-gradient(135deg, #7a5ca3 0%, #9e54bd 100%);
}

.btn:disabled {
opacity: 0.6;
cursor: not-allowed;
transform: none;
}

.card {
background: rgba(255, 255, 255, 0.05);
backdrop-filter: blur(10px);
border: 1px solid rgba(255, 255, 255, 0.1);
border-radius: 16px;
padding: 20px;
transition: all 0.3s ease;
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
margin: 15px 0;
}

h1 {
font-size: 3rem;
font-weight: 700;
text-align: center;
background: linear-gradient(135deg, #ffffff 0%, #e0c3fc 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
margin-bottom: 30px;
}

.input {
width: 100%;
padding: 12px 16px;
border: 1px solid rgba(255, 255, 255, 0.2);
border-radius: 12px;
background: rgba(255, 255, 255, 0.05);
color: white;
font-size: 16px;
transition: all 0.3s ease;
backdrop-filter: blur(10px);
margin: 10px 0;
}

.input:focus {
outline: none;
border-color: #8e44ad;
box-shadow: 0 0 0 3px rgba(142, 68, 173, 0.2);
background: rgba(255, 255, 255, 0.08);
}

.input::placeholder {
color: rgba(255, 255, 255, 0.5);
}

.status {
position: fixed;
top: 20px;
right: 20px;
padding: 8px 16px;
border-radius: 20px;
font-size: 12px;
font-weight: 600;
z-index: 1000;
background: #2ecc71;
color: white;
}

.status.offline {
background: #e74c3c;
}

.status.connecting {
background: #f39c12;
}

.error {
background: rgba(231, 76, 60, 0.1);
border: 1px solid rgba(231, 76, 60, 0.5);
color: #e74c3c;
padding: 15px;
border-radius: 12px;
margin: 20px 0;
text-align: center;
}

.players-list {
display: flex;
flex-wrap: wrap;
gap: 15px;
justify-content: center;
margin: 20px 0;
}

.player-item {
padding: 10px 20px;
background: rgba(255, 255, 255, 0.1);
border: 1px solid rgba(255, 255, 255, 0.2);
border-radius: 8px;
color: white;
font-weight: 500;
display: flex;
justify-content: space-between;
align-items: center;
}

.kick-btn {
padding: 5px 10px;
font-size: 12px;
background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
color: white;
border: none;
border-radius: 4px;
cursor: pointer;
transition: all 0.2s ease;
}

.kick-btn:hover {
background: linear-gradient(135deg, #c0392b 0%, #a93226 100%);
transform: translateY(-1px);
}

.skip-btn {
padding: 8px 16px;
font-size: 14px;
background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
color: white;
border: none;
border-radius: 6px;
cursor: pointer;
transition: all 0.2s ease;
}

.skip-btn:hover {
background: linear-gradient(135deg, #e67e22 0%, #d68910 100%);
transform: translateY(-1px);
}

.end-game-btn {
padding: 8px 16px;
font-size: 14px;
background: linear-gradient(135deg, #8e44ad 0%, #7d3c98 100%);
color: white;
border: none;
border-radius: 6px;
cursor: pointer;
transition: all 0.2s ease;
}

.end-game-btn:hover {
background: linear-gradient(135deg, #7d3c98 0%, #6c3483 100%);
transform: translateY(-1px);
}

.end-voting-btn {
padding: 8px 16px;
font-size: 14px;
background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
color: white;
border: none;
border-radius: 6px;
cursor: pointer;
transition: all 0.2s ease;
}

.end-voting-btn:hover {
background: linear-gradient(135deg, #c0392b 0%, #a93226 100%);
transform: translateY(-1px);
}

/* Game Cards */
.player-card {
background: rgba(255, 255, 255, 0.05);
border: 1px solid rgba(255, 255, 255, 0.1);
border-radius: 16px;
padding: 20px;
min-height: 400px;
transition: all 0.3s ease;
}

.player-card.current-player {
border-color: #8e44ad;
box-shadow: 0 0 20px rgba(142, 68, 173, 0.3);
}

.player-card.eliminated {
opacity: 0.5;
filter: grayscale(100%);
transform: scale(0.95);
}

.player-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 20px;
padding-bottom: 15px;
border-bottom: 1px solid rgba(255, 255, 255, 0.1);
flex-wrap: wrap;
gap: 10px;
}

.player-name {
margin: 0;
font-size: 1.2rem;
color: white;
font-weight: 600;
}

.eliminated-badge {
background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
color: white;
padding: 4px 12px;
border-radius: 20px;
font-size: 12px;
font-weight: 600;
text-transform: uppercase;
}

.vote-btn {
padding: 8px 16px;
font-size: 14px;
min-width: 100px;
background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
}

.vote-btn:hover {
background: linear-gradient(135deg, #f75c4c 0%, #d0493b 100%);
}

.characteristics-grid {
display: flex;
flex-direction: column;
gap: 12px;
}

.characteristic-item {
display: flex;
justify-content: space-between;
align-items: center;
padding: 8px 0;
border-bottom: 1px solid rgba(255, 255, 255, 0.05);
flex-wrap: wrap;
gap: 5px;
}

.characteristic-item:last-child {
border-bottom: none;
}

.characteristic-label {
color: rgba(255, 255, 255, 0.7);
font-size: 14px;
font-weight: 500;
min-width: 80px;
}

.characteristic-value {
text-align: right;
flex: 1;
margin-left: 10px;
}

.revealed-value {
color: white;
font-weight: 500;
font-size: 14px;
}

.own-value {
color: #a8e6cf;
font-weight: 500;
font-size: 14px;
background: rgba(168, 230, 207, 0.1);
padding: 2px 6px;
border-radius: 4px;
}

.characteristic-preview {
color: #a8e6cf;
font-size: 12px;
opacity: 0.8;
margin-top: 4px;
font-style: italic;
}

.hidden-value {
color: rgba(255, 255, 255, 0.4);
font-style: italic;
}

/* Action Cards */
.action-card {
background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
border-radius: 8px;
padding: 10px;
margin: 8px 0;
border: 2px solid rgba(255, 255, 255, 0.2);
transition: all 0.3s ease;
}

.action-card.used {
opacity: 0.5;
background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);
}

.action-card-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 5px;
}

.action-card-icon {
font-size: 20px;
margin-right: 8px;
}

.action-card-name {
font-weight: bold;
font-size: 14px;
color: white;
}

.action-card-description {
font-size: 12px;
color: rgba(255, 255, 255, 0.9);
margin-bottom: 8px;
}

.action-card-btn {
padding: 4px 8px;
font-size: 11px;
background: rgba(255, 255, 255, 0.2);
border: 1px solid rgba(255, 255, 255, 0.3);
border-radius: 4px;
color: white;
cursor: pointer;
transition: all 0.2s ease;
}

.action-card-btn:hover {
background: rgba(255, 255, 255, 0.3);
}

.action-card-btn:disabled {
opacity: 0.5;
cursor: not-allowed;
}

.reveal-btn {
padding: 4px 12px;
font-size: 12px;
background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
}

.reveal-btn:hover {
background: linear-gradient(135deg, #4aa8eb 0%, #3990c9 100%);
transform: translateY(-1px);
box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
}

.votes-display {
margin-top: 15px;
padding: 10px;
background: rgba(231, 76, 60, 0.1);
border: 1px solid rgba(231, 76, 60, 0.3);
border-radius: 8px;
text-align: center;
color: #e74c3c;
font-weight: 600;
}

.survivor {
padding: 15px 25px;
background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
color: white;
border-radius: 12px;
font-weight: 600;
font-size: 18px;
box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);
}

@media (max-width: 768px) {
h1 { font-size: 2rem; }
.container { padding: 10px; }
}

/* Notifications */
.notification {
position: fixed;
top: 20px;
right: 20px;
padding: 20px 25px;
border-radius: 15px;
color: white;
font-weight: 600;
z-index: 1000;
min-width: 320px;
transform: translateX(400px);
transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
backdrop-filter: blur(10px);
border: 1px solid rgba(255, 255, 255, 0.1);
}

.notification.show {
transform: translateX(0);
}

.notification.success {
background: linear-gradient(135deg, rgba(46, 204, 113, 0.9) 0%, rgba(39, 174, 96, 0.9) 100%);
border-left: 4px solid #2ecc71;
}

.notification.error {
background: linear-gradient(135deg, rgba(231, 76, 60, 0.9) 0%, rgba(192, 57, 43, 0.9) 100%);
border-left: 4px solid #e74c3c;
}

.notification.info {
background: linear-gradient(135deg, rgba(106, 76, 147, 0.9) 0%, rgba(142, 68, 173, 0.9) 100%);
border-left: 4px solid #6a4c93;
}

/* Timer */
.timer-container {
position: fixed;
top: 180px;
left: 50%;
transform: translateX(-50%);
background: linear-gradient(135deg, rgba(26, 11, 46, 0.95) 0%, rgba(45, 27, 78, 0.95) 50%, rgba(61, 44, 95, 0.95) 100%);
backdrop-filter: blur(20px);
border-radius: 15px;
padding: 15px 25px;
text-align: center;
z-index: 998;
border: 2px solid rgba(106, 76, 147, 0.5);
min-width: 280px;
max-width: 400px;
box-shadow: 0 10px 30px rgba(106, 76, 147, 0.3);
animation: timerAppear 0.5s ease-out;
}

@keyframes timerAppear {
from {
opacity: 0;
transform: translateX(-50%) translateY(-20px);
}
to {
opacity: 1;
transform: translateX(-50%) translateY(0);
}
}

.timer-display {
font-size: 2rem;
font-weight: 700;
background: linear-gradient(135deg, #6a4c93 0%, #8e44ad 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
margin: 10px 0;
font-family: 'Courier New', monospace;
text-shadow: 0 0 20px rgba(106, 76, 147, 0.5);
animation: timerPulse 1s ease-in-out infinite alternate;
}

@keyframes timerPulse {
from {
filter: brightness(1);
}
to {
filter: brightness(1.2);
}
}

.timer-message {
font-size: 1rem;
margin-bottom: 8px;
color: #ffffff;
font-weight: 600;
text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.timer-skip-btn {
background: linear-gradient(135deg, #6a4c93 0%, #8e44ad 100%);
padding: 8px 16px;
border: none;
border-radius: 8px;
color: white;
font-weight: 600;
font-size: 13px;
cursor: pointer;
transition: all 0.3s ease;
box-shadow: 0 4px 15px rgba(106, 76, 147, 0.4);
margin-top: 8px;
}

.timer-skip-btn:hover {
transform: translateY(-2px);
box-shadow: 0 6px 20px rgba(106, 76, 147, 0.6);
background: linear-gradient(135deg, #7a5ca3 0%, #9e54bd 100%);
}

.discussion-skip-btn {
background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
}

.discussion-skip-btn:hover {
background: linear-gradient(135deg, #f75f4f 0%, #d04437 100%);
box-shadow: 0 6px 20px rgba(231, 76, 60, 0.6);
}

/* Audit Log Styles */
.audit-log-btn {
position: fixed;
top: 50%;
right: 20px;
transform: translateY(-50%);
width: 50px;
height: 50px;
border: none;
border-radius: 50%;
background: linear-gradient(135deg, #6a4c93 0%, #8e44ad 100%);
color: white;
font-size: 20px;
cursor: pointer;
z-index: 1000;
box-shadow: 0 4px 15px rgba(106, 76, 147, 0.4);
transition: all 0.3s ease;
}

.audit-log-btn:hover {
transform: translateY(-50%) scale(1.1);
box-shadow: 0 6px 20px rgba(106, 76, 147, 0.6);
}

.audit-log-panel {
position: fixed;
top: 0;
right: -400px;
width: 380px;
height: 100vh;
background: linear-gradient(135deg, rgba(26, 11, 46, 0.98) 0%, rgba(45, 27, 78, 0.98) 100%);
backdrop-filter: blur(20px);
border-left: 2px solid rgba(106, 76, 147, 0.5);
z-index: 1001;
transition: right 0.4s ease;
overflow-y: auto;
}

.audit-log-panel.show {
right: 0;
}

.audit-log-header {
display: flex;
justify-content: space-between;
align-items: center;
padding: 20px;
border-bottom: 1px solid rgba(106, 76, 147, 0.3);
}

.audit-log-header h3 {
margin: 0;
color: #ffffff;
font-size: 18px;
}

.close-audit-btn {
background: none;
border: none;
color: rgba(255, 255, 255, 0.7);
font-size: 20px;
cursor: pointer;
padding: 5px;
border-radius: 50%;
transition: all 0.3s ease;
}

.close-audit-btn:hover {
background: rgba(255, 255, 255, 0.1);
color: #ffffff;
}

.audit-log-content {
padding: 20px;
}

.audit-log-entry {
padding: 12px;
margin-bottom: 10px;
background: rgba(255, 255, 255, 0.05);
border: 1px solid rgba(255, 255, 255, 0.1);
border-radius: 8px;
color: #ffffff;
font-size: 14px;
line-height: 1.4;
}

.audit-log-entry .timestamp {
color: rgba(255, 255, 255, 0.6);
font-size: 12px;
margin-bottom: 4px;
}

.audit-log-entry .action {
color: #ffffff;
}

.audit-log-entry.reveal {
border-left: 4px solid #3498db;
}

.audit-log-entry.card-action {
border-left: 4px solid #e74c3c;
}

.audit-log-entry.vote {
border-left: 4px solid #f39c12;
}

.audit-log-entry.elimination {
border-left: 4px solid #e67e22;
}

.audit-log-entry.round {
border-left: 4px solid #9b59b6;
}

/* Modal styles */
.modal {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.8);
display: flex;
justify-content: center;
align-items: center;
z-index: 1000;
}

.modal-content {
background: linear-gradient(135deg, #2c1810 0%, #4a2c2a 100%);
border-radius: 15px;
max-width: 600px;
width: 90%;
max-height: 80%;
overflow-y: auto;
box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
border: 1px solid rgba(255, 255, 255, 0.1);
}

.modal-header {
padding: 20px;
border-bottom: 1px solid rgba(255, 255, 255, 0.2);
display: flex;
justify-content: space-between;
align-items: center;
}

.modal-header h2 {
margin: 0;
color: #ffffff;
font-size: 1.5rem;
}

.modal-body {
padding: 20px;
}

.modal-body h3 {
color: #e74c3c;
margin-top: 20px;
margin-bottom: 10px;
font-size: 1.2rem;
}

.modal-body h3:first-child {
margin-top: 0;
}

.modal-body p {
color: rgba(255, 255, 255, 0.9);
line-height: 1.6;
margin-bottom: 15px;
}

.modal-footer {
padding: 20px;
border-top: 1px solid rgba(255, 255, 255, 0.2);
text-align: center;
}

.info-btn {
position: fixed;
top: 80px;
right: 20px;
background: rgba(44, 24, 16, 0.9);
border: 1px solid rgba(255, 255, 255, 0.2);
border-radius: 50%;
width: 50px;
height: 50px;
color: white;
font-size: 1.5rem;
cursor: pointer;
transition: all 0.3s ease;
z-index: 100;
}

.info-btn:hover {
background: rgba(74, 44, 42, 0.9);
transform: scale(1.1);
}
</style>
</head>
<body>
<div class="status" id="status">üü° Connecting...</div>

<div class="container">
<!-- Login Screen -->
<div id="lobby" class="screen">
<h1>Bunker Game</h1>
<div style="max-width: 400px; margin: 0 auto;">
<div class="card">
<h2 style="text-align: center; margin-bottom: 20px;">ÔøΩ Bunker Rooms</h2>
<input type="text" id="playerName" placeholder="Enter your name" class="input" maxlength="20">
<input type="text" id="roomId" placeholder="Room ID (leave empty for random)" class="input" maxlength="10" style="margin-top: 8px;">
<button id="joinBtn" class="btn" style="width: 100%;">Join/Create Room</button>
<button id="clearDataBtn" class="btn" style="width: 100%; margin-top: 8px; background: rgba(255,255,255,0.1); font-size: 12px;">Clear Saved Data</button>

<div id="error" class="error" style="display: none;">
Connection error!
</div>

<div style="text-align: center; margin-top: 20px; color: rgba(255,255,255,0.7); font-size: 14px;">
<p>One lobby for all players worldwide!</p>
<p>First player becomes the host</p>
</div>
</div>
</div>
</div>

<!-- Waiting Screen -->
<div id="waiting" class="screen hidden">
<h1>Global Lobby</h1>
<div class="card" style="text-align: center;">
<h2 id="waitingTitle">Players in lobby: 0/8</h2>

<div id="playersList" class="players-list"></div>

<button id="startBtn" class="btn" style="display: none;">Start Game</button>

<div style="margin-top: 20px; color: rgba(255,255,255,0.7);">
<p>Minimum 2 players to start</p>
</div>
</div>
</div>

<!-- Game Screen -->
<div id="game" class="screen hidden">
<h1>Bunker Game</h1>
<div style="display: flex; justify-content: center; gap: 30px; margin: 20px 0; font-size: 16px; color: rgba(255, 255, 255, 0.8); flex-wrap: wrap;">
<span id="roundInfo" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">Round: 1</span>
<span id="phaseInfo" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">Phase: Revealing</span>
<span id="slotsInfo" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">Bunker slots: 2</span>
</div>
<div id="statusMessage" style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 12px; color: #ffffff; font-weight: 500; backdrop-filter: blur(10px);"></div>
<div id="playersGrid" style="display: grid; gap: 20px; justify-content: center; margin: 80px auto 0; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); max-width: 1200px;"></div>

<!-- Audit Log Button -->
<button id="auditLogBtn" class="audit-log-btn">üìã</button>

<!-- Audit Log Panel -->
<div id="auditLogPanel" class="audit-log-panel hidden">
<div class="audit-log-header">
<h3>üìã Game Log</h3>
<button id="closeAuditLog" class="close-audit-btn">‚úï</button>
</div>
<div id="auditLogContent" class="audit-log-content">
<!-- Log entries will be added here -->
</div>
</div>
</div>

<!-- Game End Screen -->
<div id="gameEnd" class="screen hidden">
<h1>Game Over!</h1>
<div class="card" style="text-align: center;">
<h2>üéâ Survivors:</h2>
<div id="survivors" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin: 20px 0;"></div>
<button id="restartBtn" class="btn">New Game</button>
</div>
</div>
</div>

<!-- Scenario Modal -->
<div id="scenarioModal" class="modal" style="display: none;">
<div class="modal-content">
<div class="modal-header">
<h2 id="scenarioTitle">Game Scenario</h2>
<div id="scenarioTimer" class="timer">30</div>
</div>
<div class="modal-body">
<div id="scenarioStory">
<h3 id="storyTitle">Story</h3>
<p id="storyDescription"></p>
</div>
<div id="scenarioBunker">
<h3 id="bunkerTitle">Bunker</h3>
<p id="bunkerDescription"></p>
</div>
</div>
<div class="modal-footer">
<button id="scenarioCloseBtn" class="btn">Start Game</button>
</div>
</div>
</div>

<!-- Info Button for reopening scenario -->
<button id="scenarioInfoBtn" class="info-btn" style="display: none;" title="View Scenario">üìã</button>

<script>
// Game data
const professions = [
'Doctor', 'Teacher', 'Engineer', 'Chef', 'Police Officer', 'Firefighter',
'Programmer', 'Architect', 'Electrician', 'Plumber', 'Mechanic',
'Farmer', 'Veterinarian', 'Psychologist', 'Journalist', 'Artist',
'Musician', 'Actor', 'Dancer', 'Writer', 'Librarian',
'Salesperson', 'Accountant', 'Lawyer', 'Judge', 'Military Officer',
'Stripper', 'Venereologist', 'Webcam Model', 'YouTuber', 'Adult Store Clerk', 
'Drop Hunter', 'Content Creator', 'IT Specialist', 'Pilot', 'Flight Attendant', 'Driver', 'Mail Carrier', 'Security Guard'
];

const health = [
'Healthy', 'Nearsighted', 'Asthma', 'Diabetes', 'Nut Allergy',
'Hypertension', 'Arthritis', 'Migraines', 'Insomnia', 'Depression',
'Anxiety', 'Sports Injury', 'Heart Surgery', 'Prosthetic Leg',
'Hearing Aid', 'Chronic Back Pain', 'Epilepsy',
'Anemia', 'Poor Coordination', 'Chronic Fatigue'
];

// Special health conditions for Doctor card
const severeHealthConditions = [
'Dwarfism', 'Cerebral Palsy', 'Cancer', 'Completely Blind', 
'Completely Deaf', 'Paralyzed', 'No Arms', 'No Legs'
];

const hobbies = [
'Reading', 'Sports', 'Cooking', 'Drawing', 'Music', 'Dancing',
'Photography', 'Gardening', 'Fishing', 'Hunting', 'Traveling',
'Collecting', 'Knitting', 'Chess', 'Video Games', 'Movies',
'Theater', 'Astronomy', 'Geology', 'Archaeology', 'History',
'Languages', 'Programming', 'Robotics', 'Modeling',
'Rock Climbing', 'Skydiving', 'Diving', 'Surfing', 'Yoga'
];

const phobias = [
'Arachnophobia (spiders)', 'Claustrophobia (enclosed spaces)', 
'Acrophobia (heights)', 'Aerophobia (flying)', 'Aquaphobia (water)',
'Social phobia (people)', 'Agoraphobia (open spaces)',
'Nyctophobia (darkness)', 'Ophidiophobia (snakes)', 'Cynophobia (dogs)',
'Mysophobia (dirt)', 'Hemophobia (blood)', 'Thanatophobia (death)',
'Autophobia (loneliness)', 'Phonophobia (loud sounds)',
'Pyrophobia (fire)', 'Trypophobia (holes)', 'Entomophobia (insects)',
'Meteorophobia (weather)', 'Xenophobia (strangers)'
];

const baggage = [
'Backpack with food', 'First aid kit', 'Tool set',
'Sleeping bag', 'Tent', 'Flashlight with batteries',
'Radio', 'Compass and maps', '50m rope', 'Knife',
'Lighter', 'Waterproof matches', 'Canned food', '10L water',
'Blanket', 'Spare clothes', 'Books', 'Playing cards',
'Musical instrument', 'Camera', 'Documents',
'Money', 'Jewelry', 'Family photos', 'Weapon',
'Alcohol', 'Cigarettes', 'Medicine', 'Plant seeds', 'Fishing rod'
];

const facts = [
'Served in military', 'Knows martial arts', 'Can cook',
'Speaks 3 languages', 'Has driving license', 'Can sew',
'Knows first aid', 'Can repair tech', 'Good shooter',
'Knows wilderness survival', 'Knows psychology', 'Can sing',
'Good dancer', 'Plays instrument', 'Knows history',
'Quick at math', 'Good memory', 'Knows geography',
'Can draw maps', 'Knows astronomy', 'Can predict weather',
'Good navigation', 'Can climb trees', 'Fast runner',
'Strong hands', 'Good eyesight', 'Sharp hearing', 'Senses danger',
'Persuasive', 'Good leader'
];

// Game scenarios data
const scenarios = [
{
title: "Nuclear Winter",
description: "After a series of explosions in major cities, the atmosphere was filled with radioactive dust. The sun is barely visible, the temperature drops rapidly, and the snow has absorbed radiation. People hide in bunkers, as every breath on the surface means the risk of contamination."
},
{
title: "Chemical Fog", 
description: "At a secret factory, an accident released a massive cloud of toxic gases into the atmosphere. Entire regions were covered, turning streets into dead zones. The gas, heavier than air, accumulates in basements and lowlands, cutting off escape routes."
}
];

const bunkers = [
{
title: "Research Bunker",
description: "The bunker, about 180 m¬≤, consists of a central corridor with adjoining rooms: a shared sleeping area, a storage room with gas masks and filters, a recreation room with a TV and an old game console, and a small medical bay. In a separate section, there is a chemical cabinet with instruments for air analysis and a collection of reagents."
},
{
title: "Living Complex Bunker",
description: "The bunker, about 220 m¬≤, is divided into several sections: a living sector with small cabins, a common dining room with canned supplies, a technical room with generators and ventilation, and a small library filled with books and board games. In the corner, there is an improvised laboratory with dosimeters and simple reagents for testing water."
}
];

const characteristicNames = {
profession: 'Profession',
health: 'Health',
hobbies: 'Hobbies',
phobias: 'Phobias',
baggage: 'Baggage',
facts1: 'Special Skill 1',
facts2: 'Special Skill 2',
gender: 'Gender',
age: 'Age'
};

function getRandomItem(array) {
return array[Math.floor(Math.random() * array.length)];
}

function generateRandomCharacteristics() {
return {
profession: getRandomItem(professions),
health: getRandomItem(health),
hobbies: getRandomItem(hobbies),
phobias: getRandomItem(phobias),
baggage: getRandomItem(baggage),
facts1: getRandomItem(facts),
facts2: getRandomItem(facts),
gender: getRandomItem(['Male', 'Female']),
age: Math.floor(Math.random() * 70) + 21
};
}

// Action Cards System
const actionCards = [
{
id: 'swap_characteristic',
name: 'Characteristic Swap',
description: 'Exchange one characteristic with another player',
icon: 'üîÑ',
type: 'targeted',
usage: 'revealing'
},
{
id: 'immunity',
name: 'Immunity Shield', 
description: 'Cannot be eliminated this round',
icon: 'üõ°Ô∏è',
type: 'passive',
usage: 'voting'
},
{
id: 'double_vote',
name: 'Double Vote',
description: 'Your vote counts as 2 votes this round',
icon: 'üó≥Ô∏è',
type: 'passive',
usage: 'voting'
},
{
id: 'spy',
name: 'Spy',
description: 'See one random hidden characteristic of target player',
icon: 'üîç',
type: 'targeted',
usage: 'revealing'
},
{
id: 'force_reveal',
name: 'Force Reveal',
description: 'Force target player to reveal a characteristic',
icon: 'üëÅÔ∏è',
type: 'targeted',
usage: 'revealing'
},
{
id: 'block_vote',
name: 'Vote Block',
description: 'Target player cannot vote this round',
icon: 'üö´',
type: 'targeted',
usage: 'voting'
},
{
id: 'revenge',
name: 'Revenge',
description: 'Add 20 years to any player when eliminated',
icon: '‚ö°',
type: 'revenge',
usage: 'elimination'
},
{
id: 'doctor',
name: 'Doctor',
description: 'Heal yourself or worsen another player\'s health',
icon: '‚öïÔ∏è',
type: 'targeted',
usage: 'revealing'
},
{
id: 'age_deal',
name: 'Age Deal',
description: 'Swap ages with another player',
icon: 'üî¢',
type: 'targeted',
usage: 'revealing'
},
{
id: 'replace_profession',
name: 'Replace Profession',
description: 'Replace target player\'s profession with random one',
icon: 'üíº',
type: 'targeted',
usage: 'revealing'
},
{
id: 'replace_health',
name: 'Replace Health',
description: 'Replace target player\'s health with random one',
icon: '‚ù§Ô∏è',
type: 'targeted',
usage: 'revealing'
},
{
id: 'replace_phobia',
name: 'Replace Phobia',
description: 'Replace target player\'s phobia with random one',
icon: 'üò®',
type: 'targeted',
usage: 'revealing'
},
{
id: 'replace_fact',
name: 'Replace Fact',
description: 'Replace one fact of target player with random one',
icon: 'üìã',
type: 'targeted',
usage: 'revealing'
},
{
id: 'replace_baggage',
name: 'Replace Baggage',
description: 'Replace target player\'s baggage with random one',
icon: 'üéí',
type: 'targeted',
usage: 'revealing'
},
{
id: 'replace_hobby',
name: 'Replace Hobby',
description: 'Replace target player\'s hobby with random one',
icon: 'üé®',
type: 'targeted',
usage: 'revealing'
},
{
id: 'change_any',
name: 'Universal Change',
description: 'Replace any characteristic of target player',
icon: 'üé≤',
type: 'targeted',
usage: 'revealing'
},
{
id: 'thief',
name: 'Thief',
description: 'Steal baggage from another player',
icon: 'ü•∑',
type: 'targeted',
usage: 'revealing'
},
{
id: 'job_swap',
name: 'Job Swap',
description: 'Swap professions with another player',
icon: 'üîÄ',
type: 'targeted',
usage: 'revealing'
}
];

// Helper function to display age with modifier
function getDisplayAge(player, characteristic) {
if (characteristic === 'age') {
const baseAge = parseInt(player.characteristics.age) || 25;
const modifier = player.ageModifier || 0;
const ageRevealed = player.revealedCharacteristics?.includes('age');

if (modifier !== 0 && !ageRevealed) {
return `${baseAge} ${modifier > 0 ? '+' : ''}${modifier} years old (hidden +${modifier})`;
}
return `${baseAge + modifier} years old`;
}
return player.characteristics[characteristic];
}

function getRandomActionCard() {
return actionCards[Math.floor(Math.random() * actionCards.length)];
}

// Player persistence functions
function generatePlayerId() {
return 'player-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
}

function generateRoomId() {
return Math.random().toString(36).substr(2, 6).toUpperCase();
}

function savePlayerData(playerId, nickname, roomId) {
const playerData = {
playerId,
nickname,
roomId,
timestamp: Date.now()
};
localStorage.setItem('bunker-player-data', JSON.stringify(playerData));
}

// –î–æ–±–∞–≤–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
function saveGameStateBackup() {
if (gameState && gameState.players && gameState.players.length > 0) {
const backup = {
gameState: gameState,
currentPlayer: currentPlayer,
timestamp: Date.now()
};
localStorage.setItem('bunker-game-backup', JSON.stringify(backup));
console.log('üíæ Game state backup saved');
}
}

// –§—É–Ω–∫—Ü–∏—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
function restoreGameStateBackup() {
try {
const backup = localStorage.getItem('bunker-game-backup');
if (backup) {
const data = JSON.parse(backup);
// –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ backup —Å–≤–µ–∂–∏–π (–Ω–µ —Å—Ç–∞—Ä—à–µ 10 –º–∏–Ω—É—Ç)
if (Date.now() - data.timestamp < 10 * 60 * 1000) {
console.log('üîÑ Restoring game state from backup');
return data;
} else {
console.log('‚è∞ Backup too old, not restoring');
localStorage.removeItem('bunker-game-backup');
}
}
} catch (error) {
console.error('‚ùå Error restoring backup:', error);
}
return null;
}function getStoredPlayerData() {
try {
const data = localStorage.getItem('bunker-player-data');
if (data) {
const parsed = JSON.parse(data);
// Check if data is not older than 24 hours
if (Date.now() - parsed.timestamp < 24 * 60 * 60 * 1000) {
return parsed;
}
}
} catch (error) {
console.error('Error reading stored player data:', error);
}
return null;
}

function clearStoredPlayerData() {
localStorage.removeItem('bunker-player-data');
}

// Scenario functions
function getRandomScenario() {
const story = scenarios[Math.floor(Math.random() * scenarios.length)];
const bunker = bunkers[Math.floor(Math.random() * bunkers.length)];
return { story, bunker };
}

function showScenario(scenario) {
if (!elements.scenarioModal || !elements.storyTitle) {
console.error('‚ùå Scenario elements not found');
return;
}

// Don't show again if already visible
if (elements.scenarioModal.style.display === 'flex') {
return;
}

console.log('üé¨ Showing scenario to player');

elements.storyTitle.textContent = scenario.story.title;
elements.storyDescription.textContent = scenario.story.description;
elements.bunkerTitle.textContent = scenario.bunker.title;
elements.bunkerDescription.textContent = scenario.bunker.description;

elements.scenarioModal.style.display = 'flex';

// Start 30-second timer
let timeLeft = 30;
elements.scenarioTimer.textContent = timeLeft;

const timerInterval = setInterval(() => {
timeLeft--;
elements.scenarioTimer.textContent = timeLeft;

if (timeLeft <= 0) {
clearInterval(timerInterval);
hideScenario();
}
}, 1000);

// Store timer reference for cleanup
elements.scenarioModal.timerInterval = timerInterval;
}

function hideScenario() {
if (elements.scenarioModal.timerInterval) {
clearInterval(elements.scenarioModal.timerInterval);
}
elements.scenarioModal.style.display = 'none';
elements.scenarioInfoBtn.style.display = 'block';

// Only host can advance to next phase
if (gameState.phase === 'scenario' && isHost) {
gameState.phase = 'revealing';
gameState.currentPlayerId = gameState.players[0].id;

updateCurrentGameState();
console.log('üéÆ Host advanced to revealing phase');
}
}

function reopenScenario() {
// Show modal without timer for quick reference
elements.scenarioModal.style.display = 'flex';
elements.scenarioTimer.textContent = '‚àû';
}// API for Vercel functions
class VercelAPI {
constructor() {
this.isOnline = false;
this.debug = true;
}

log(message) {
if (this.debug) {
console.log(`[API] ${message}`);
}
}

async init() {
this.log('üåê Checking API...');

try {
const response = await fetch('/api/game', {
method: 'GET',
headers: { 'Content-Type': 'application/json' },
signal: AbortSignal.timeout(5000)
});

this.isOnline = response.ok;
this.log(this.isOnline ? '‚úÖ API ready' : '‚ùå API unavailable');
return this.isOnline;
} catch (error) {
this.log(`‚ùå API error: ${error.message}`);
this.isOnline = false;
return false;
}
}

async joinGame(playerData) {
try {
const response = await fetch('/api/game', {
method: 'POST',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify({
action: 'join',
player: playerData,
roomId: playerData.roomId
})
});if (response.ok) {
const result = await response.json();
this.log(`‚úÖ Player joined. Total: ${result.players.length}`);
return result;
} else {
const error = await response.text();
throw new Error(error || 'Server error');
}
} catch (error) {
this.log(`‚ùå Join error: ${error.message}`);
throw error;
}
}

async getGameState(roomId) {
try {
const url = roomId ? `/api/game?roomId=${encodeURIComponent(roomId)}` : '/api/game';
const response = await fetch(url);
if (response.ok) {
return await response.json();
}
return null;
} catch (error) {
this.log(`‚ùå Error getting state: ${error.message}`);
return null;
}
}

async updateGameState(gameState, roomId) {
try {
const response = await fetch('/api/game', {
method: 'PUT',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify({
action: 'update',
gameState: gameState,
roomId: roomId
})
});

return response.ok;
} catch (error) {
this.log(`‚ùå Update error: ${error.message}`);
return false;
}
}
}

// Game state
let gameState = null;
let currentPlayer = null;
let isHost = false;
let hasVoted = false;
let api = null;
let syncInterval = null;
let currentTimer = null;
let timerInterval = null;
let lastNotificationTime = 0;

// Helper function to update game state with current room
async function updateCurrentGameState() {
// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã –≤–∞–ª–∏–¥–Ω–æ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π
if (!gameState || !gameState.players || gameState.players.length === 0) {
console.error('‚ùå Trying to update invalid game state:', gameState);
return false;
}

const roomId = currentPlayer?.roomId || gameState?.roomId || 'default';
console.log('üîÑ Updating game state for room:', roomId, {
phase: gameState.phase,
players: gameState.players.length,
currentPlayer: gameState.currentPlayerId
});

try {
const result = await api.updateGameState(gameState, roomId);
console.log('‚úÖ Game state updated successfully');
return result;
} catch (error) {
console.error('‚ùå Failed to update game state:', error);
return false;
}
}

// DOM elements
const elements = {
lobby: document.getElementById('lobby'),
waiting: document.getElementById('waiting'),
game: document.getElementById('game'),
gameEnd: document.getElementById('gameEnd'),
playerName: document.getElementById('playerName'),
roomId: document.getElementById('roomId'),
joinBtn: document.getElementById('joinBtn'),
clearDataBtn: document.getElementById('clearDataBtn'),
startBtn: document.getElementById('startBtn'),
restartBtn: document.getElementById('restartBtn'),
waitingTitle: document.getElementById('waitingTitle'),
playersList: document.getElementById('playersList'),
playersGrid: document.getElementById('playersGrid'),
roundInfo: document.getElementById('roundInfo'),
phaseInfo: document.getElementById('phaseInfo'),
slotsInfo: document.getElementById('slotsInfo'),
statusMessage: document.getElementById('statusMessage'),
survivors: document.getElementById('survivors'),
status: document.getElementById('status'),
error: document.getElementById('error'),
scenarioModal: document.getElementById('scenarioModal'),
scenarioTitle: document.getElementById('scenarioTitle'),
scenarioTimer: document.getElementById('scenarioTimer'),
storyTitle: document.getElementById('storyTitle'),
storyDescription: document.getElementById('storyDescription'),
bunkerTitle: document.getElementById('bunkerTitle'),
bunkerDescription: document.getElementById('bunkerDescription'),
scenarioCloseBtn: document.getElementById('scenarioCloseBtn'),
scenarioInfoBtn: document.getElementById('scenarioInfoBtn'),
auditLogBtn: document.getElementById('auditLogBtn'),
auditLogPanel: document.getElementById('auditLogPanel'),
closeAuditLog: document.getElementById('closeAuditLog'),
auditLogContent: document.getElementById('auditLogContent')
};

// Check if critical elements exist
const missingElements = [];
Object.keys(elements).forEach(key => {
if (!elements[key]) {
missingElements.push(key);
}
});

if (missingElements.length > 0) {
console.error('‚ùå Missing DOM elements:', missingElements);
}

// Initialization
document.addEventListener('DOMContentLoaded', async function() {
console.log('üéÆ Bunker Game loading...');

api = new VercelAPI();
const isConnected = await api.init();

updateStatus(isConnected ? 'üü¢ Ready to play' : 'üî¥ API unavailable');

// Try to restore player nickname and room from storage
const storedData = getStoredPlayerData();
if (storedData && storedData.nickname) {
elements.playerName.value = storedData.nickname;
elements.playerName.style.backgroundColor = 'rgba(106, 76, 147, 0.2)';
elements.playerName.placeholder = 'Previously used name (click to change)';
if (storedData.roomId) {
elements.roomId.value = storedData.roomId;
elements.roomId.style.backgroundColor = 'rgba(106, 76, 147, 0.2)';
}
console.log('üîÑ Restored player data:', storedData.nickname, 'Room:', storedData.roomId);
}

setupEventListeners();
showScreen('lobby');

console.log('‚úÖ Game ready!');
});

function setupEventListeners() {
console.log('üîó Setting up event listeners...');

elements.joinBtn.addEventListener('click', joinGame);
elements.clearDataBtn.addEventListener('click', () => {
clearStoredPlayerData();
elements.playerName.value = '';
elements.roomId.value = '';
showNotification('Saved data cleared!', 'success');
});
elements.startBtn.addEventListener('click', startGame);
elements.restartBtn.addEventListener('click', restartGame);

// Scenario modal event listeners
if (elements.scenarioCloseBtn) {
elements.scenarioCloseBtn.addEventListener('click', hideScenario);
}
if (elements.scenarioInfoBtn) {
elements.scenarioInfoBtn.addEventListener('click', reopenScenario);
}

// Close modal when clicking outside
if (elements.scenarioModal) {
elements.scenarioModal.addEventListener('click', (e) => {
if (e.target === elements.scenarioModal) {
hideScenario();
}
});
}

elements.playerName.addEventListener('keypress', (e) => {
if (e.key === 'Enter') {
joinGame();
}
});

// Audit log event listeners
if (elements.auditLogBtn) {
elements.auditLogBtn.addEventListener('click', toggleAuditLog);
}
if (elements.closeAuditLog) {
elements.closeAuditLog.addEventListener('click', closeAuditLog);
}
if (elements.auditLogPanel) {
elements.auditLogPanel.addEventListener('click', (e) => {
e.stopPropagation();
});
}
document.addEventListener('click', (e) => {
if (!elements.auditLogPanel.contains(e.target) && !elements.auditLogBtn.contains(e.target)) {
closeAuditLog();
}
});
}

function showScreen(screenName) {
console.log('üì∫ Switching to screen:', screenName);
const screens = ['lobby', 'waiting', 'game', 'gameEnd'];
screens.forEach(screen => {
if (elements[screen]) {
elements[screen].classList.add('hidden');
}
});
if (elements[screenName]) {
elements[screenName].classList.remove('hidden');
}
}

function updateStatus(message) {
elements.status.textContent = message;
elements.status.className = 'status';
if (message.includes('üî¥')) {
elements.status.classList.add('offline');
} else if (message.includes('üü°')) {
elements.status.classList.add('connecting');
}
}

function showError(message) {
elements.error.textContent = message;
elements.error.style.display = 'block';
}

function hideError() {
elements.error.style.display = 'none';
}

async function joinGame() {
const name = elements.playerName.value.trim();
let roomId = elements.roomId.value.trim().toUpperCase();

hideError();
updateStatus('üü° Connecting...');

if (!name) {
showError('Enter name!');
updateStatus('üî¥ Error');
return;
}

// Generate random room ID if not provided
if (!roomId) {
roomId = generateRoomId();
elements.roomId.value = roomId;
console.log('üé≤ Generated room ID:', roomId);
}

if (!api.isOnline) {
showError('API unavailable! Check connection.');
updateStatus('üî¥ API unavailable');
return;
}

try {
elements.joinBtn.disabled = true;

// Try to get stored player data
const storedData = getStoredPlayerData();
let playerId;
let isReconnection = false;

// Check if this is a genuine reconnection (same name AND same room)
if (storedData && storedData.nickname === name && storedData.roomId === roomId) {
// Use existing player ID only if name AND room match
playerId = storedData.playerId;
isReconnection = true;
console.log('üîÑ Reconnecting with existing player ID:', playerId);
} else if (storedData && storedData.roomId === roomId) {
// Same room but different name - try to check if player still exists in game
console.log('üîç Same room but different name, checking if player exists...');
const currentGameState = await api.getGameState(roomId);
if (currentGameState && currentGameState.players) {
const existingPlayer = currentGameState.players.find(p => p.id === storedData.playerId);
if (existingPlayer) {
playerId = storedData.playerId;
isReconnection = true;
console.log('üîÑ Found existing player in game, reconnecting with stored ID:', playerId);
} else {
playerId = generatePlayerId();
console.log('üÜï Player not found in game, creating new player ID:', playerId);
}
} else {
playerId = generatePlayerId();
console.log('üÜï No game state found, creating new player ID:', playerId);
}
} else {
// Generate new player ID for new name or different room
playerId = generatePlayerId();
console.log('üÜï Creating new player ID:', playerId);

// Show notification if player changed name/room
if (storedData) {
if (storedData.nickname !== name) {
showNotification(`Starting fresh with new name: ${name}`, 'info');
} else if (storedData.roomId !== roomId) {
showNotification(`Joining new room: ${roomId}`, 'info');
}
}
}

const newPlayer = {
id: playerId,
name: name,
roomId: roomId,
characteristics: generateRandomCharacteristics(),
revealedCharacteristics: [],
actionCard: getRandomActionCard(), // –î–æ–±–∞–≤–ª—è–µ–º –∫–∞—Ä—Ç–æ—á–∫—É –¥–µ–π—Å—Ç–≤–∏—è
actionCardUsed: false, // –§–ª–∞–≥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∫–∞—Ä—Ç–æ—á–∫–∏
isAlive: true,
votesReceived: 0
};

// Check if name is already taken in this room (unless it's a genuine reconnection)
if (!isReconnection) {
const currentGameState = await api.getGameState(roomId);
if (currentGameState && currentGameState.players.some(p => p.name === name)) {
showError('Name already taken in this room!');
updateStatus('üî¥ Error');
elements.joinBtn.disabled = false;
return;
}
}

// –ï—Å–ª–∏ —ç—Ç–æ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ, –ø–æ–ø—Ä–æ–±—É–µ–º —Å–Ω–∞—á–∞–ª–∞ –ø–æ–ª—É—á–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
if (isReconnection) {
console.log('üîÑ Attempting reconnection, checking existing game state...');
const existingState = await api.getGameState(roomId);

if (existingState && existingState.players && existingState.players.length > 0) {
// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∏–≥—Ä–æ–∫ –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏
const existingPlayer = existingState.players.find(p => p.id === playerId || p.name === name);

if (existingPlayer) {
console.log('‚úÖ Found existing player in game state, reconnecting...');
gameState = existingState;
currentPlayer = existingPlayer;

// –û–±–Ω–æ–≤–ª—è–µ–º room ID –∏–≥—Ä–æ–∫–∞ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
if (currentPlayer.roomId !== roomId) {
currentPlayer.roomId = roomId;
}
} else {
console.log('‚ùå Player not found in existing state, joining as new...');
gameState = await api.joinGame(newPlayer);
}
} else {
console.log('‚ùå No existing game state found, joining as new...');
gameState = await api.joinGame(newPlayer);
}
} else {
// –ù–æ–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
gameState = await api.joinGame(newPlayer);
}

// –ï—Å–ª–∏ –ø–æ–ª—É—á–∏–ª–∏ –ø—É—Å—Ç–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ, –ø–æ–ø—Ä–æ–±—É–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏–∑ backup
if (!gameState || !gameState.players || gameState.players.length === 0) {
console.warn('‚ö†Ô∏è Received empty game state, trying to restore from backup');
const backup = restoreGameStateBackup();
if (backup && backup.gameState && backup.currentPlayer) {
gameState = backup.gameState;
console.log('üîÑ Restored game state from backup');
} else {
// –ï—Å–ª–∏ –∏ backup –Ω–µ –ø–æ–º–æ–≥, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –∏ –ø—Ä–µ—Ä—ã–≤–∞–µ–º
showError('Failed to join room. Please try again.');
updateStatus('üî¥ Error');
elements.joinBtn.disabled = false;
return;
}
}

// Find actual player data from server (in case of reconnection)
if (!isReconnection || !currentPlayer) {
const serverPlayer = gameState.players.find(p => p.id === newPlayer.id);
currentPlayer = serverPlayer || newPlayer;
}

isHost = (gameState.hostId === currentPlayer.id);
console.log('üéØ Player setup complete:', {
playerId: currentPlayer.id,
playerName: currentPlayer.name,
isHost: isHost,
hostId: gameState.hostId,
isReconnection: isReconnection
});

// Restore voting state if in voting phase
if (gameState.phase === 'voting' && gameState.votingResults) {
// Check if this player already voted by checking if any vote was cast from their session
// Since we can't perfectly track individual votes, we'll be conservative
hasVoted = false; // Reset on reconnection to allow voting
console.log('üó≥Ô∏è Restored voting state - player can vote');
}

// Save player data for reconnection
savePlayerData(currentPlayer.id, currentPlayer.name, roomId);

// –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ gameState –≤–∞–ª–∏–¥–µ–Ω –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º UI
if (!gameState || !gameState.players) {
console.error('‚ùå gameState is invalid after join, cannot update UI');
showError('Game state error. Please refresh and try again.');
updateStatus('üî¥ Error');
elements.joinBtn.disabled = false;
return;
}

// Use existing updateUI function to show correct screen based on game phase
updateUI();

startSync();

console.log(`üéØ Successfully joined/reconnected - Phase: ${gameState.phase}, Player: ${currentPlayer.name}`);
} catch (error) {
console.error('‚ùå Login error:', error);
showError('Error: ' + error.message);
updateStatus('üî¥ Error');
elements.joinBtn.disabled = false;
}
}

function updateWaitingScreen() {
const hostIndicator = isHost ? ' (You are host üëë)' : '';
const roomIndicator = currentPlayer?.roomId ? ` - Room: ${currentPlayer.roomId}` : '';
elements.waitingTitle.textContent = `Players in lobby: ${gameState.players.length}/8${hostIndicator}${roomIndicator}`;

elements.playersList.innerHTML = '';
gameState.players.forEach(player => {
const div = document.createElement('div');
div.className = 'player-item';

const nameSpan = document.createElement('span');
const hostIcon = player.id === gameState.hostId ? 'üëë ' : '';
nameSpan.textContent = hostIcon + player.name;
div.appendChild(nameSpan);

// Host can kick other players (but not themselves)
if (isHost && player.id !== currentPlayer?.id) {
console.log('üîß Adding kick button for player:', {
playerName: player.name, 
isHost: isHost, 
currentPlayerId: currentPlayer?.id, 
hostId: gameState.hostId
});
const kickBtn = document.createElement('button');
kickBtn.className = 'btn kick-btn';
kickBtn.textContent = 'üö´';
kickBtn.title = 'Kick player';
kickBtn.onclick = () => kickPlayer(player.id);
div.appendChild(kickBtn);
}

elements.playersList.appendChild(div);
});

// Host can start game with 2+ players
if (gameState.players.length >= 2 && isHost) {
elements.startBtn.style.display = 'block';
} else {
elements.startBtn.style.display = 'none';
}
}

async function kickPlayer(playerId) {
console.log('üö´ Kick player called:', {
playerId: playerId,
isHost: isHost,
currentPlayerId: currentPlayer?.id,
hostId: gameState.hostId,
gamePhase: gameState.phase
});

if (!isHost) {
showNotification('Only host can kick players!', 'error');
return;
}

if (gameState.phase !== 'waiting') {
showNotification('Can only kick players in lobby!', 'error');
return;
}

const playerToKick = gameState.players.find(p => p.id === playerId);
if (!playerToKick) return;

// Remove player from list
gameState.players = gameState.players.filter(p => p.id !== playerId);
gameState.lastUpdate = Date.now();

await updateCurrentGameState();
updateWaitingScreen();
showNotification(`Player ${playerToKick.name} kicked from game`, 'info');
}

let isStartingGame = false;

async function startGame() {
if (isStartingGame) {
console.log('üîÑ Game is already starting, ignoring duplicate call');
return;
}

if (!isHost) {
showNotification('Only host can start the game!', 'error');
return;
}

if (gameState.players.length < 2) {
showNotification('Minimum 2 players required to start!', 'error');
return;
}

isStartingGame = true;
console.log('üéÆ Starting game...');

try {
// Generate scenario first
const scenario = getRandomScenario();
gameState.scenario = scenario;

// Clear audit log for new game
clearAuditLog();
addToAuditLog('round', `üéÆ Game started! Players: ${gameState.players.map(p => p.name).join(', ')}`, '');
addToAuditLog('round', `üìñ Scenario: ${scenario.title}`, '');

// Set scenario phase first
gameState.phase = 'scenario';
gameState.round = 1;
gameState.bunkerSlots = Math.max(1, Math.floor(gameState.players.length / 2));

// Update state for all players immediately
await updateCurrentGameState();

console.log('‚úÖ Game started successfully with scenario phase');
} catch (error) {
console.error('‚ùå Error starting game:', error);
showNotification('Error starting game!', 'error');
} finally {
isStartingGame = false;
}
}

function startSync(interval = 2000) {
if (syncInterval) {
clearInterval(syncInterval);
}

console.log(`üîÑ Starting sync with ${interval}ms interval`);
syncInterval = setInterval(async () => {
try {
const latestState = await api.getGameState(currentPlayer?.roomId);

// –ó–∞—â–∏—Ç–∞ –æ—Ç –ø–æ—Ç–µ—Ä–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
if (latestState && latestState.players && latestState.players.length > 0) {
if (latestState.lastUpdate > gameState.lastUpdate) {
console.log('üîÑ Updating game state:', {
phase: latestState.phase,
players: latestState.players.length,
currentPlayer: latestState.currentPlayerId
});

// –°–ø–µ—Ü–∏–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–≥—Ä—ã
if (latestState.phase === 'ended') {
console.log('üèÅ Game ended detected in sync! Showing end screen for all players');
console.log('üîç Current game state phase:', gameState.phase);
console.log('üîç Latest state phase:', latestState.phase);
}

// –°–æ—Ö—Ä–∞–Ω—è–µ–º hasVoted –µ—Å–ª–∏ –º—ã –≤ —Ñ–∞–∑–µ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—è
const wasVoting = gameState.phase === 'voting';
const stillVoting = latestState.phase === 'voting';

// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –ª–∏ –Ω–æ–≤–æ–µ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ (—Å–ø–∏—Å–æ–∫ –ø—Ä–æ–≥–æ–ª–æ—Å–æ–≤–∞–≤—à–∏—Ö —Å–±—Ä–æ—à–µ–Ω)
const isNewVoting = stillVoting && (!latestState.playersWhoVoted || latestState.playersWhoVoted.length === 0);

const preserveVoteStatus = wasVoting && stillVoting && hasVoted && !isNewVoting;

if (preserveVoteStatus) {
console.log('üó≥Ô∏è Preserving vote status during sync');
} else if (isNewVoting && hasVoted) {
console.log('üÜï New voting round detected, resetting vote status');
}

gameState = latestState;

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º hasVoted —Å —Å–µ—Ä–≤–µ—Ä–Ω—ã–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º
if (gameState.phase === 'voting' && gameState.playersWhoVoted && currentPlayer?.id) {
const hasVotedOnServer = gameState.playersWhoVoted.includes(currentPlayer.id);
if (hasVotedOnServer && !hasVoted) {
console.log('üîÑ Syncing hasVoted=true from server state');
hasVoted = true;
} else if (!hasVotedOnServer && hasVoted && !preserveVoteStatus) {
console.log('üîÑ Syncing hasVoted=false from server state');
hasVoted = false;
}
}

// –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º hasVoted –µ—Å–ª–∏ –Ω—É–∂–Ω–æ, –∏–Ω–∞—á–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –¥–ª—è –Ω–æ–≤–æ–≥–æ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—è
if (preserveVoteStatus) {
hasVoted = true;
} else if (isNewVoting) {
hasVoted = false;
}

// –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —Ö–æ—Å—Ç–∞ –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
// –•–æ—Å—Ç –æ—Å—Ç–∞–µ—Ç—Å—è —Ö–æ—Å—Ç–æ–º –¥–∞–∂–µ –µ—Å–ª–∏ –∏—Å–∫–ª—é—á–µ–Ω –∏–∑ –∏–≥—Ä—ã
isHost = (gameState.hostId === currentPlayer?.id);

if (isHost) {
const hostPlayer = gameState.players.find(p => p.id === currentPlayer?.id);
if (hostPlayer && !hostPlayer.isAlive) {
console.log('üëë Host is eliminated but retains host privileges');
}
}

updateUI();

// Update audit log display when game state changes
updateAuditLogDisplay();

// Check for global notifications
if (gameState.lastGlobalNotification && gameState.lastGlobalNotification.timestamp > (lastNotificationTime || 0)) {
showNotification(gameState.lastGlobalNotification.message, 'info');
lastNotificationTime = gameState.lastGlobalNotification.timestamp;
}

// –°–æ—Ö—Ä–∞–Ω—è–µ–º backup —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
saveGameStateBackup();

console.log('‚úÖ State synchronized successfully');
}
} else {
console.warn('‚ö†Ô∏è Received empty or invalid game state, keeping current state');

// –ï—Å–ª–∏ —É –Ω–∞—Å –µ—Å—Ç—å –≤–∞–ª–∏–¥–Ω–æ–µ —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ, –ø–æ–ø—Ä–æ–±—É–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –µ–≥–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
if (gameState && gameState.players && gameState.players.length > 0) {
console.log('üîÑ Attempting to restore valid game state on server...');
try {
// –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–±–æ–ª—å—à—É—é –∑–∞–¥–µ—Ä–∂–∫—É, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤
await new Promise(resolve => setTimeout(resolve, 1000));
await api.updateGameState(gameState);
console.log('‚úÖ Successfully restored game state on server');
} catch (restoreError) {
console.error('‚ùå Failed to restore game state:', restoreError);
}
}
}
} catch (error) {
console.error('‚ùå Sync error:', error);
}
}, interval);
}

function updateUI() {
if (gameState.phase === 'waiting') {
showScreen('waiting');
updateWaitingScreen();
hideTimer();
} else if (gameState.phase === 'scenario') {
showScreen('game');
if (gameState.scenario) {
showScenario(gameState.scenario);
}
} else if (gameState.phase === 'ended') {
console.log('üèÅ Showing game end screen for player');
showScreen('gameEnd');
updateSurvivors();
hideTimer();
} else if (['revealing', 'discussion', 'voting'].includes(gameState.phase)) {
showScreen('game');
updateGameInfo();
updatePlayersGrid();
updateGameStatus();

// Show info button if scenario exists
if (gameState.scenario) {
elements.scenarioInfoBtn.style.display = 'block';
}

// Start timer for revealing if this is current player
if (gameState.phase === 'revealing' && gameState.currentPlayerId) {
const isCurrentPlayer = currentPlayer && gameState.currentPlayerId === currentPlayer.id;

console.log(`üîç Timer check: phase=${gameState.phase}, currentPlayerId=${gameState.currentPlayerId}, isCurrentPlayer=${isCurrentPlayer}, hasTimer=${!!document.getElementById('gameTimer')}`);

if (isCurrentPlayer && !document.getElementById('gameTimer')) {
// Check if player still needs to reveal characteristics
const player = gameState.players.find(p => p.id === currentPlayer.id);
const revealedInCurrentRound = player?.revealedInCurrentRound || 0;
const maxReveals = gameState.round === 1 ? 2 : 1;
const hasMoreToReveal = revealedInCurrentRound < maxReveals;

console.log(`üéØ Reveal check for ${currentPlayer.name}: round=${gameState.round}, revealedThisRound=${revealedInCurrentRound}/${maxReveals}, hasMore=${hasMoreToReveal}`);

// Only start timer if player actually needs to reveal more
if (hasMoreToReveal) {
console.log(`üéØ Starting timer for ${currentPlayer.name} (${revealedInCurrentRound}/${maxReveals})`);
startRevealTimer();
} else {
console.log(`‚úÖ Player ${currentPlayer.name} already revealed enough this round (${revealedInCurrentRound}/${maxReveals})`);
}
} else if (isCurrentPlayer) {
console.log(`‚è∞ Timer already exists for ${currentPlayer.name}`);
}
}

// Start discussion timer for ALL players when in discussion phase
if (gameState.phase === 'discussion' && !document.getElementById('gameTimer')) {
console.log('üí¨ Starting discussion timer for all players');
showTimer(300, 'üí¨ –û–±—Å—É–∂–¥–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ–º (5 –º–∏–Ω—É—Ç)', async () => {
// Timer finished, start voting
gameState.phase = 'voting';
gameState.playersWhoVoted = [];
gameState.processingVoting = false;
gameState.discussionSkipVotes = [];
await updateCurrentGameState();
}, false, {
skipButton: true,
skipText: '–ó–∞–≤–µ—Ä—à–∏—Ç—å –æ–±—Å—É–∂–¥–µ–Ω–∏–µ',
skipAction: async () => await skipDiscussion()
});
}

// Hide timer when moving from discussion to voting
if (gameState.phase === 'voting' && document.getElementById('gameTimer')) {
const timer = document.getElementById('gameTimer');
if (timer && timer.querySelector('.timer-message')?.textContent?.includes('–û–±—Å—É–∂–¥–µ–Ω–∏–µ')) {
console.log('üó≥Ô∏è Hiding discussion timer, moving to voting');
hideTimer();
}
}
}
}

function updateGameInfo() {
elements.roundInfo.textContent = `Round: ${gameState.round}`;

const phaseNames = {
revealing: 'Revealing',
discussion: 'Discussion',
voting: 'Voting',
ended: 'Game Over'
};
elements.phaseInfo.textContent = `Phase: ${phaseNames[gameState.phase]}`;

// Create container for slots and end game button
elements.slotsInfo.innerHTML = '';

const slotsText = document.createElement('span');
slotsText.textContent = `Bunker slots: ${gameState.bunkerSlots}`;
elements.slotsInfo.appendChild(slotsText);

// Add end game button for host
if (isHost && gameState.phase !== 'ended') {
const endBtn = document.createElement('button');
endBtn.className = 'btn end-game-btn';
endBtn.textContent = 'üèÅ End Game';
endBtn.title = 'Force end game (host)';
endBtn.onclick = () => forceEndGame();
endBtn.style.marginLeft = '15px';
elements.slotsInfo.appendChild(endBtn);
}
}

function updateGameStatus() {
if (!gameState || gameState === null || gameState === undefined) {
console.log('updateGameStatus: gameState is invalid, skipping update:', gameState);
return;
}

console.log('üîß updateGameStatus - Host check:', {
currentPlayerId: currentPlayer?.id,
hostId: gameState.hostId,
isHost: isHost,
calculated_isHost: (gameState.hostId === currentPlayer?.id)
});

// –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º isHost
// –•–æ—Å—Ç –æ—Å—Ç–∞–µ—Ç—Å—è —Ö–æ—Å—Ç–æ–º –¥–∞–∂–µ –µ—Å–ª–∏ –∏—Å–∫–ª—é—á–µ–Ω
isHost = (gameState.hostId === currentPlayer?.id);

console.log('üîß Host status updated:', {
isHost: isHost,
hostId: gameState.hostId,
currentPlayerId: currentPlayer?.id,
hostIsAlive: gameState.players.find(p => p.id === gameState.hostId)?.isAlive
});

let message = '';
elements.statusMessage.innerHTML = ''; // Clear content

if (gameState.phase === 'revealing' && gameState.currentPlayerId) {
const currentPlayerName = gameState.players.find(p => p.id === gameState.currentPlayerId)?.name;
message = `${currentPlayerName} is revealing characteristic`;

// Add skip turn button for host
if (isHost) {
console.log('üîß Adding skip button for host:', {
isHost: isHost, 
currentPlayerId: currentPlayer?.id, 
hostId: gameState.hostId
});
const messageSpan = document.createElement('span');
messageSpan.textContent = message;
elements.statusMessage.appendChild(messageSpan);

const skipBtn = document.createElement('button');
skipBtn.className = 'btn skip-btn';
skipBtn.textContent = '‚è≠Ô∏è Skip Turn';
skipBtn.title = 'Skip player turn (host)';
skipBtn.onclick = () => skipCurrentTurn();
skipBtn.style.marginLeft = '15px';
elements.statusMessage.appendChild(skipBtn);
} else {
elements.statusMessage.textContent = message;
}
} else if (gameState.phase === 'discussion') {
const alivePlayers = gameState.players.filter(p => p.isAlive);
const requiredVotes = Math.ceil(alivePlayers.length * 0.5);
const currentVotes = gameState.discussionSkipVotes?.length || 0;

console.log(`üí¨ Updating status: discussion phase, ${currentVotes}/${requiredVotes} votes, alive: ${alivePlayers.length}`);

message = `üí¨ Discussion phase - ${currentVotes}/${requiredVotes} voted to skip`;
elements.statusMessage.textContent = message;
} else if (gameState.phase === 'voting') {
message = 'üó≥Ô∏è Voting! Choose who to eliminate';

console.log('üîß Voting phase - checking host status:', {
isHost: isHost, 
currentPlayerId: currentPlayer?.id, 
hostId: gameState.hostId
});

if (isHost) {
const messageSpan = document.createElement('span');
messageSpan.textContent = message;
elements.statusMessage.appendChild(messageSpan);

const endVotingBtn = document.createElement('button');
endVotingBtn.className = 'btn end-voting-btn';
endVotingBtn.textContent = 'üèÅ End Voting';
endVotingBtn.title = 'End voting early (host)';
endVotingBtn.onclick = () => processVoting();
endVotingBtn.style.marginLeft = '15px';
elements.statusMessage.appendChild(endVotingBtn);
} else {
elements.statusMessage.textContent = message;
}
} else {
elements.statusMessage.textContent = message;
}
}

function updatePlayersGrid() {
elements.playersGrid.innerHTML = '';

gameState.players.forEach(player => {
const card = createPlayerCard(player);
elements.playersGrid.appendChild(card);
});
}

function createPlayerCard(player) {
const card = document.createElement('div');
card.className = `player-card ${!player.isAlive ? 'eliminated' : ''} ${gameState.currentPlayerId === player.id ? 'current-player' : ''}`;

const header = document.createElement('div');
header.className = 'player-header';

const name = document.createElement('h3');
name.className = 'player-name';
const hostIcon = player.id === gameState.hostId ? 'üëë ' : '';
name.textContent = hostIcon + player.name;
header.appendChild(name);

if (!player.isAlive) {
const badge = document.createElement('span');
badge.className = 'eliminated-badge';
badge.textContent = 'Eliminated';
header.appendChild(badge);
}

// Show voting block indicator
if (player.cannotVote && gameState.phase === 'voting') {
const blockBadge = document.createElement('span');
blockBadge.className = 'eliminated-badge'; // Reuse style
blockBadge.textContent = 'üö´ Blocked';
blockBadge.style.background = '#e74c3c';
header.appendChild(blockBadge);
}

// Check if current player can vote (not blocked)
const currentPlayerInGame = gameState.players.find(p => p.id === currentPlayer?.id);
const canCurrentPlayerVote = !currentPlayerInGame?.cannotVote;

// Check if current player has already voted (client or server side)
const hasAlreadyVoted = hasVoted || (gameState.playersWhoVoted && gameState.playersWhoVoted.includes(currentPlayer?.id));

// Check if current player is alive
const isCurrentPlayerAlive = currentPlayer?.isAlive;

if (gameState.phase === 'voting' && player.id !== currentPlayer?.id && player.isAlive && !hasAlreadyVoted && canCurrentPlayerVote && isCurrentPlayerAlive) {
console.log(`üó≥Ô∏è Creating vote button for player ${player.name}:`, {
phase: gameState.phase,
playerId: player.id,
currentPlayerId: currentPlayer?.id,
playerAlive: player.isAlive,
currentPlayerAlive: isCurrentPlayerAlive,
hasVoted: hasVoted,
hasAlreadyVoted: hasAlreadyVoted,
canVote: canCurrentPlayerVote
});
const voteBtn = document.createElement('button');
voteBtn.className = 'btn vote-btn';
voteBtn.textContent = 'Vote';
voteBtn.onclick = () => vote(player.id);
header.appendChild(voteBtn);
} else if (gameState.phase === 'voting') {
console.log(`‚ùå Not creating vote button for player ${player.name}:`, {
phase: gameState.phase,
playerId: player.id,
currentPlayerId: currentPlayer?.id,
playerAlive: player.isAlive,
currentPlayerAlive: isCurrentPlayerAlive,
hasVoted: hasVoted,
hasAlreadyVoted: hasAlreadyVoted,
canVote: canCurrentPlayerVote,
isSamePlayer: player.id === currentPlayer?.id
});
}

card.appendChild(header);

const charGrid = document.createElement('div');
charGrid.className = 'characteristics-grid';

Object.keys(player.characteristics || {}).forEach(char => {
const item = document.createElement('div');
item.className = 'characteristic-item';

const label = document.createElement('div');
label.className = 'characteristic-label';
label.textContent = `${characteristicNames[char]}:`;

const value = document.createElement('div');
value.className = 'characteristic-value';

// Check if this is own player or another player
const isOwnPlayer = player.id === currentPlayer?.id;
const isRevealed = player.revealedCharacteristics?.includes(char);

if (isOwnPlayer) {
// Own characteristics are always visible
if (gameState.phase === 'revealing' && gameState.currentPlayerId === player.id && !isRevealed) {
// Count characteristics revealed in CURRENT round only
const revealedInCurrentRound = player.revealedInCurrentRound || 0;
const maxReveals = gameState.round === 1 ? 2 : 1; // 2 in first round, 1 in others
const canReveal = revealedInCurrentRound < maxReveals;

console.log(`üîç Reveal logic for ${player.name}: round=${gameState.round}, revealedThisRound=${revealedInCurrentRound}/${maxReveals}, canReveal=${canReveal}`);

// In first round, force profession first, then any other
const shouldShowRevealButton = canReveal && (
gameState.round !== 1 || // Not first round - can reveal any
(gameState.round === 1 && revealedInCurrentRound === 0 && char === 'profession') || // First round, first reveal - must be profession
(gameState.round === 1 && revealedInCurrentRound === 1 && char !== 'profession') // First round, second reveal - any except profession
);

if (shouldShowRevealButton) {
// Can reveal this characteristic
console.log(`üîç Creating reveal button for ${player.name}, char: ${char}, round: ${gameState.round}, revealed: ${revealedInCurrentRound}/${maxReveals}`);
const revealBtn = document.createElement('button');
revealBtn.className = 'btn reveal-btn';
revealBtn.textContent = 'Reveal';
revealBtn.onclick = () => revealCharacteristic(char);
value.appendChild(revealBtn);

// Show preview of own characteristic
const preview = document.createElement('div');
preview.className = 'characteristic-preview';
preview.textContent = getDisplayAge(player, char);
value.appendChild(preview);
} else {
console.log(`‚ùå No reveal button for ${player.name}, char: ${char}, canReveal: ${canReveal}, shouldShow: ${shouldShowRevealButton}`);
// Cannot reveal this characteristic right now, or already revealed
const revealed = document.createElement('span');
revealed.className = 'own-value';
revealed.textContent = getDisplayAge(player, char);
value.appendChild(revealed);
}
} else {
// Show own characteristic
const revealed = document.createElement('span');
revealed.className = isRevealed ? 'revealed-value' : 'own-value';
revealed.textContent = getDisplayAge(player, char);
value.appendChild(revealed);
}
} else {
// Other players' characteristics are only visible if revealed
if (isRevealed) {
const revealed = document.createElement('span');
revealed.className = 'revealed-value';
revealed.textContent = getDisplayAge(player, char);
value.appendChild(revealed);
} else {
const hidden = document.createElement('span');
hidden.className = 'hidden-value';
hidden.textContent = '???';
value.appendChild(hidden);
}
}

item.appendChild(label);
item.appendChild(value);
charGrid.appendChild(item);
});

card.appendChild(charGrid);

// Add action card display
if (player.actionCard && player.id === currentPlayer?.id) {
const actionCardDiv = document.createElement('div');
actionCardDiv.className = `action-card ${player.actionCardUsed ? 'used' : ''}`;

const cardHeader = document.createElement('div');
cardHeader.className = 'action-card-header';

const cardIcon = document.createElement('span');
cardIcon.className = 'action-card-icon';
cardIcon.textContent = player.actionCard.icon;

const cardName = document.createElement('span');
cardName.className = 'action-card-name';
cardName.textContent = player.actionCard.name;

cardHeader.appendChild(cardIcon);
cardHeader.appendChild(cardName);

const cardDescription = document.createElement('div');
cardDescription.className = 'action-card-description';
cardDescription.textContent = player.actionCard.description;

actionCardDiv.appendChild(cardHeader);
actionCardDiv.appendChild(cardDescription);

// Add use button if card is not used and can be used in current phase
const canUse = !player.actionCardUsed && 
((player.actionCard.usage === 'revealing' && gameState.phase === 'revealing') ||
(player.actionCard.usage === 'voting' && gameState.phase === 'voting'));

if (canUse) {
const useBtn = document.createElement('button');
useBtn.className = 'action-card-btn';
useBtn.textContent = 'Use Card';
useBtn.onclick = () => useActionCard(player.actionCard);
actionCardDiv.appendChild(useBtn);
}

card.appendChild(actionCardDiv);
}

// Show votes during voting phase (real-time) or after voting
const hasVotes = player.votesReceived > 0 || (gameState.detailedVotes && gameState.detailedVotes[player.id] && gameState.detailedVotes[player.id].length > 0);
const showVotes = hasVotes && (gameState.phase === 'voting' || player.votesReceived > 0);

if (showVotes) {
const votesDisplay = document.createElement('div');
votesDisplay.className = 'votes-display';

// Calculate current votes from detailedVotes for real-time display
let currentVotes = 0;
if (gameState.detailedVotes && gameState.detailedVotes[player.id]) {
currentVotes = gameState.detailedVotes[player.id].reduce((sum, vote) => sum + vote.weight, 0);
}

// Use the higher value between votesReceived and calculated votes
const displayVotes = Math.max(player.votesReceived || 0, currentVotes);
votesDisplay.textContent = `Votes: ${displayVotes}`;

// Show detailed vote information if available
if (gameState.detailedVotes && gameState.detailedVotes[player.id]) {
const votersList = document.createElement('div');
votersList.className = 'voters-list';
votersList.style.cssText = `
       margin-top: 8px;
       font-size: 12px;
       color: rgba(255, 255, 255, 0.8);
       line-height: 1.4;
   `;

const votersText = gameState.detailedVotes[player.id]
.map(vote => vote.weight > 1 ? `${vote.voterName} (x${vote.weight})` : vote.voterName)
.join(', ');

votersList.textContent = `Voted by: ${votersText}`;
votesDisplay.appendChild(votersList);
}

card.appendChild(votesDisplay);
}

return card;
}

// Action Card Functions
function useActionCard(actionCard) {
console.log(`üÉè Using action card: ${actionCard.name}`);

if (actionCard.type === 'targeted') {
// Show player selection modal for targeted cards
showPlayerSelectionModal(actionCard);
} else if (actionCard.type === 'revenge') {
// Revenge cards are passive - activate immediately
applyActionCardEffect(actionCard, null);
} else {
// Apply passive effect immediately
applyActionCardEffect(actionCard, null);
}
}

function showPlayerSelectionModal(actionCard) {
// Create modal for selecting target player
const modal = document.createElement('div');
modal.className = 'modal';
modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
  `;

const modalContent = document.createElement('div');
modalContent.style.cssText = `
      background: #2c2c54;
      padding: 20px;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      color: white;
  `;

const title = document.createElement('h3');
title.textContent = `Select target for ${actionCard.name}`;
title.style.marginBottom = '15px';
modalContent.appendChild(title);

// Special case for Doctor card - add self-heal option
if (actionCard.id === 'doctor') {
const selfHealBtn = document.createElement('button');
selfHealBtn.className = 'btn';
selfHealBtn.textContent = 'Heal Yourself';
selfHealBtn.style.cssText = `
          display: block;
          width: 100%;
          margin: 5px 0;
          padding: 10px;
          background: #27ae60;
      `;
selfHealBtn.onclick = () => {
applyActionCardEffect(actionCard, null); // null means self-target
document.body.removeChild(modal);
};
modalContent.appendChild(selfHealBtn);

// Add separator
const separator = document.createElement('div');
separator.textContent = 'OR';
separator.style.cssText = `
          text-align: center;
          margin: 10px 0;
          color: #bdc3c7;
          font-size: 14px;
      `;
modalContent.appendChild(separator);

const subtitle = document.createElement('h4');
subtitle.textContent = 'Choose player to worsen:';
subtitle.style.cssText = `
          margin: 10px 0;
          font-size: 16px;
          color: #e74c3c;
      `;
modalContent.appendChild(subtitle);
}

// Add player buttons
gameState.players.filter(p => p.isAlive && p.id !== currentPlayer?.id).forEach(player => {
const playerBtn = document.createElement('button');
playerBtn.className = 'btn';
playerBtn.textContent = player.name;
playerBtn.style.cssText = `
          display: block;
          width: 100%;
          margin: 5px 0;
          padding: 10px;
      `;
playerBtn.onclick = () => {
applyActionCardEffect(actionCard, player.id);
document.body.removeChild(modal);
};
modalContent.appendChild(playerBtn);
});

// Add cancel button
const cancelBtn = document.createElement('button');
cancelBtn.className = 'btn';
cancelBtn.textContent = 'Cancel';
cancelBtn.style.cssText = `
      display: block;
      width: 100%;
      margin: 10px 0 0 0;
      padding: 10px;
      background: #7f8c8d;
  `;
cancelBtn.onclick = () => document.body.removeChild(modal);
modalContent.appendChild(cancelBtn);

modal.appendChild(modalContent);
document.body.appendChild(modal);
}

async function applyActionCardEffect(actionCard, targetPlayerId) {
const currentPlayerInGame = gameState.players.find(p => p.id === currentPlayer?.id);
if (!currentPlayerInGame) return;

console.log(`üéØ Applying ${actionCard.name} effect`, targetPlayerId ? `to player ${targetPlayerId}` : '');

// Create global notification about card usage
const targetPlayerName = targetPlayerId ? 
gameState.players.find(p => p.id === targetPlayerId)?.name : 'no target';

const notificationMessage = targetPlayerId ? 
`${currentPlayerInGame.name} used "${actionCard.name}" on ${targetPlayerName}` :
`${currentPlayerInGame.name} used "${actionCard.name}"`;

// Log the action card usage
const logMessage = targetPlayerId ? 
`${currentPlayerInGame.name} used "${actionCard.name}" on ${targetPlayerName}` :
`${currentPlayerInGame.name} used "${actionCard.name}"`;
addToAuditLog('card-action', logMessage, currentPlayerInGame.name);

// Show notification to all players
showActionCardNotification(notificationMessage);

// Mark card as used
currentPlayerInGame.actionCardUsed = true;

// Apply specific card effects
switch (actionCard.id) {
case 'immunity':
currentPlayerInGame.hasImmunity = true;
showNotification('üõ°Ô∏è You have immunity this round!', 'success');
break;

case 'double_vote':
currentPlayerInGame.hasDoubleVote = true;
showNotification('üó≥Ô∏è Your vote counts double this round!', 'success');
break;

case 'spy':
if (targetPlayerId) {
const targetPlayer = gameState.players.find(p => p.id === targetPlayerId);
if (targetPlayer) {
showSpyModal(targetPlayer);
}
}
break;

case 'swap_characteristic':
if (targetPlayerId) {
showCharacteristicSwapModal(targetPlayerId);
}
break;

case 'force_reveal':
if (targetPlayerId) {
forcePlayerReveal(targetPlayerId);
}
break;

case 'block_vote':
if (targetPlayerId) {
const targetPlayer = gameState.players.find(p => p.id === targetPlayerId);
if (targetPlayer) {
targetPlayer.cannotVote = true;
showNotification(`üö´ ${targetPlayer.name} cannot vote this round!`, 'success');
}
}
break;

case 'revenge':
// Store revenge card for use during elimination
currentPlayerInGame.hasRevengeCard = true;
showNotification('‚ö° Revenge card prepared! You can age someone if eliminated.', 'success');
break;

case 'doctor':
if (targetPlayerId) {
await showDoctorModal(targetPlayerId);
} else {
// Self-heal
await showDoctorSelfHealModal();
}
break;

case 'age_deal':
if (targetPlayerId) {
await swapAges(currentPlayerInGame, targetPlayerId);
}
break;

case 'replace_profession':
if (targetPlayerId) {
await replaceCharacteristic(targetPlayerId, 'profession', professions);
}
break;

case 'replace_health':
if (targetPlayerId) {
await replaceCharacteristic(targetPlayerId, 'health', health);
}
break;

case 'replace_phobia':
if (targetPlayerId) {
await replaceCharacteristic(targetPlayerId, 'phobia', phobias);
}
break;

case 'replace_fact':
if (targetPlayerId) {
showFactReplaceModal(targetPlayerId);
}
break;

case 'replace_baggage':
if (targetPlayerId) {
await replaceCharacteristic(targetPlayerId, 'baggage', baggage);
}
break;

case 'replace_hobby':
if (targetPlayerId) {
await replaceCharacteristic(targetPlayerId, 'hobby', hobbies);
}
break;

case 'change_any':
if (targetPlayerId) {
showUniversalChangeModal(targetPlayerId);
}
break;

case 'thief':
if (targetPlayerId) {
await stealBaggage(currentPlayerInGame, targetPlayerId);
}
break;

case 'job_swap':
if (targetPlayerId) {
await swapProfessions(currentPlayerInGame, targetPlayerId);
}
break;
}

// Update game state
await updateCurrentGameState();

console.log(`‚úÖ Action card ${actionCard.name} used successfully`);
}

// Specific action card effect functions
function showSpyModal(targetPlayer) {
// Get unrevealed characteristics
const revealedChars = targetPlayer.revealedCharacteristics || [];
const unrevealedChars = Object.keys(targetPlayer.characteristics)
.filter(char => !revealedChars.includes(char));

if (unrevealedChars.length === 0) {
showNotification(`üîç ${targetPlayer.name} has no hidden characteristics to spy on!`, 'info');
return;
}

// Select random unrevealed characteristic
const randomChar = unrevealedChars[Math.floor(Math.random() * unrevealedChars.length)];
const charValue = targetPlayer.characteristics[randomChar];

const modal = document.createElement('div');
modal.className = 'modal';
modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
  `;

const modalContent = document.createElement('div');
modalContent.style.cssText = `
      background: #2c2c54;
      padding: 20px;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      color: white;
      text-align: center;
  `;

const title = document.createElement('h3');
title.textContent = `üîç Spied on ${targetPlayer.name}`;
title.style.marginBottom = '15px';
modalContent.appendChild(title);

const spyInfo = document.createElement('div');
spyInfo.style.cssText = `
      background: rgba(168, 230, 207, 0.1);
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      border: 1px solid rgba(168, 230, 207, 0.3);
  `;

const charLabel = document.createElement('div');
charLabel.textContent = `${characteristicNames[randomChar]}:`;
charLabel.style.cssText = `
      font-size: 14px;
      color: #a8e6cf;
      margin-bottom: 5px;
  `;

const charValueEl = document.createElement('div');
charValueEl.textContent = randomChar === 'age' ? getDisplayAge(targetPlayer, randomChar) : charValue;
charValueEl.style.cssText = `
      font-size: 16px;
      font-weight: bold;
      color: white;
  `;

spyInfo.appendChild(charLabel);
spyInfo.appendChild(charValueEl);
modalContent.appendChild(spyInfo);

const closeBtn = document.createElement('button');
closeBtn.className = 'btn';
closeBtn.textContent = 'Close';
closeBtn.style.cssText = `
      display: block;
      width: 100%;
      margin: 15px 0 0 0;
      padding: 10px;
  `;
closeBtn.onclick = () => document.body.removeChild(modal);
modalContent.appendChild(closeBtn);

modal.appendChild(modalContent);
document.body.appendChild(modal);

showNotification(`üîç Discovered ${targetPlayer.name}'s ${characteristicNames[randomChar]}!`, 'success');
}

function showCharacteristicSwapModal(targetPlayerId) {
const currentPlayerInGame = gameState.players.find(p => p.id === currentPlayer?.id);
const targetPlayer = gameState.players.find(p => p.id === targetPlayerId);

if (!currentPlayerInGame || !targetPlayer) return;

// Create modal for selecting which characteristic to swap
const modal = document.createElement('div');
modal.className = 'modal';
modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
  `;

const modalContent = document.createElement('div');
modalContent.style.cssText = `
      background: #2c2c54;
      padding: 20px;
      border-radius: 12px;
      max-width: 500px;
      width: 90%;
      color: white;
  `;

const title = document.createElement('h3');
title.textContent = `Choose characteristic to swap with ${targetPlayer.name}`;
title.style.cssText = `
      margin-bottom: 15px;
      text-align: center;
      color: #9b59b6;
  `;
modalContent.appendChild(title);

// Show your characteristics for selection
const yourCharsTitle = document.createElement('h4');
yourCharsTitle.textContent = 'Your characteristics:';
yourCharsTitle.style.cssText = `
      margin: 10px 0;
      color: #3498db;
  `;
modalContent.appendChild(yourCharsTitle);

// Add buttons for each characteristic
Object.keys(currentPlayerInGame.characteristics).forEach(charKey => {
const charBtn = document.createElement('button');
charBtn.className = 'btn';
charBtn.textContent = `${characteristicNames[charKey]}: ${currentPlayerInGame.characteristics[charKey]}`;
charBtn.style.cssText = `
          display: block;
          width: 100%;
          margin: 5px 0;
          padding: 10px;
          text-align: left;
          background: #34495e;
          border: 2px solid #9b59b6;
      `;
charBtn.onclick = () => {
swapCharacteristic(currentPlayerInGame, targetPlayer, charKey);
document.body.removeChild(modal);
};
modalContent.appendChild(charBtn);
});

// Add cancel button
const cancelBtn = document.createElement('button');
cancelBtn.className = 'btn';
cancelBtn.textContent = 'Cancel';
cancelBtn.style.cssText = `
      display: block;
      width: 100%;
      margin: 15px 0 0 0;
      padding: 10px;
      background: #7f8c8d;
  `;
cancelBtn.onclick = () => document.body.removeChild(modal);
modalContent.appendChild(cancelBtn);

modal.appendChild(modalContent);
document.body.appendChild(modal);
}

async function swapCharacteristic(player1, player2, characteristicKey) {
// Swap the selected characteristic
const value1 = player1.characteristics[characteristicKey];
const value2 = player2.characteristics[characteristicKey];

// Perform the swap
const temp = player1.characteristics[characteristicKey];
player1.characteristics[characteristicKey] = player2.characteristics[characteristicKey];
player2.characteristics[characteristicKey] = temp;

// Also update in gameState.players array to ensure consistency
const gameStatePlayer1 = gameState.players.find(p => p.id === player1.id);
const gameStatePlayer2 = gameState.players.find(p => p.id === player2.id);

if (gameStatePlayer1 && gameStatePlayer2) {
gameStatePlayer1.characteristics[characteristicKey] = player1.characteristics[characteristicKey];
gameStatePlayer2.characteristics[characteristicKey] = player2.characteristics[characteristicKey];
}

// Update currentPlayer if affected
if (currentPlayer && (currentPlayer.id === player1.id || currentPlayer.id === player2.id)) {
if (currentPlayer.id === player1.id) {
currentPlayer.characteristics[characteristicKey] = player1.characteristics[characteristicKey];
} else {
currentPlayer.characteristics[characteristicKey] = player2.characteristics[characteristicKey];
}
}

showNotification(`üîÑ Swapped ${characteristicNames[characteristicKey]} with ${player2.name}!`, 'success');
console.log(`üîÑ Characteristic swap: ${characteristicNames[characteristicKey]} between ${player1.name} and ${player2.name}`);

// Add to audit log
gameState.auditLog.push({
timestamp: new Date().toLocaleTimeString(),
message: `üîÑ Characteristic Swap used: ${player1.name} (${value1}) and ${player2.name} (${value2}) swapped ${characteristicNames[characteristicKey]}`,
type: 'action'
});

// Global notification for all players
gameState.lastGlobalNotification = {
message: `üîÑ Characteristic Swap used: ${player1.name} (${value1}) and ${player2.name} (${value2}) swapped ${characteristicNames[characteristicKey]}`,
timestamp: Date.now()
};

// Update game state on server
await updateCurrentGameState();
}

function forcePlayerReveal(targetPlayerId) {
const targetPlayer = gameState.players.find(p => p.id === targetPlayerId);
if (targetPlayer) {
const unrevealedChars = Object.keys(targetPlayer.characteristics)
.filter(char => !targetPlayer.revealedCharacteristics?.includes(char));

if (unrevealedChars.length > 0) {
const randomChar = unrevealedChars[Math.floor(Math.random() * unrevealedChars.length)];
targetPlayer.revealedCharacteristics = targetPlayer.revealedCharacteristics || [];
targetPlayer.revealedCharacteristics.push(randomChar);

showNotification(`üëÅÔ∏è Forced ${targetPlayer.name} to reveal ${characteristicNames[randomChar]}!`, 'success');
}
}
}

// New action card functions
async function showDoctorModal(targetPlayerId) {
const targetPlayer = gameState.players.find(p => p.id === targetPlayerId);
if (!targetPlayer) return;

// Check if target's health is revealed
const healthRevealed = targetPlayer.revealedCharacteristics?.includes('health');
if (!healthRevealed) {
showNotification('‚ùå Target player\'s health must be revealed to use Doctor card!', 'error');
return;
}

// Apply random severe condition
const randomCondition = severeHealthConditions[Math.floor(Math.random() * severeHealthConditions.length)];
const oldHealth = targetPlayer.characteristics.health;
targetPlayer.characteristics.health = randomCondition;

showNotification(`‚öïÔ∏è Worsened ${targetPlayer.name}'s health to ${randomCondition}!`, 'success');

// Global notification for all players
gameState.lastGlobalNotification = {
message: `‚öïÔ∏è Doctor card used: ${targetPlayer.name}'s health changed from "${oldHealth}" to "${randomCondition}"`,
timestamp: Date.now()
};

await updateCurrentGameState();
}

async function showDoctorSelfHealModal() {
const currentPlayerInGame = gameState.players.find(p => p.id === currentPlayer?.id);
if (!currentPlayerInGame) return;

// Check if own health is revealed
const healthRevealed = currentPlayerInGame.revealedCharacteristics?.includes('health');
if (!healthRevealed) {
showNotification('‚ùå Your health must be revealed to heal yourself!', 'error');
return;
}

const oldHealth = currentPlayerInGame.characteristics.health;
currentPlayerInGame.characteristics.health = 'Completely Healthy';
showNotification('‚öïÔ∏è You healed yourself completely!', 'success');

// Global notification for all players
gameState.lastGlobalNotification = {
message: `‚öïÔ∏è Doctor card used: ${currentPlayerInGame.name} healed themselves from "${oldHealth}" to "Completely Healthy"`,
timestamp: Date.now()
};

await updateCurrentGameState();
}

async function swapAges(currentPlayer, targetPlayerId) {
const targetPlayer = gameState.players.find(p => p.id === targetPlayerId);
if (!targetPlayer) return;

// Check if both ages are revealed
const currentAgeRevealed = currentPlayer.revealedCharacteristics?.includes('age');
const targetAgeRevealed = targetPlayer.revealedCharacteristics?.includes('age');

if (!currentAgeRevealed || !targetAgeRevealed) {
showNotification('‚ùå Both players\' ages must be revealed to swap!', 'error');
return;
}

// Swap ages
const currentAge = currentPlayer.characteristics.age;
const targetAge = targetPlayer.characteristics.age;

const temp = currentPlayer.characteristics.age;
currentPlayer.characteristics.age = targetPlayer.characteristics.age;
targetPlayer.characteristics.age = temp;

// Also update in gameState.players array to ensure consistency
const gameStateCurrentPlayer = gameState.players.find(p => p.id === currentPlayer.id);
const gameStateTargetPlayer = gameState.players.find(p => p.id === targetPlayer.id);

if (gameStateCurrentPlayer && gameStateTargetPlayer) {
gameStateCurrentPlayer.characteristics.age = currentPlayer.characteristics.age;
gameStateTargetPlayer.characteristics.age = targetPlayer.characteristics.age;
}

// Update currentPlayer global reference if needed
if (window.currentPlayer && window.currentPlayer.id === currentPlayer.id) {
window.currentPlayer.characteristics.age = currentPlayer.characteristics.age;
}

showNotification(`üî¢ Swapped ages with ${targetPlayer.name}!`, 'success');

// Add to audit log
gameState.auditLog.push({
timestamp: new Date().toLocaleTimeString(),
message: `üî¢ Age Deal used: ${currentPlayer.name} (${currentAge}) and ${targetPlayer.name} (${targetAge}) swapped ages`,
type: 'action'
});

// Global notification for all players
gameState.lastGlobalNotification = {
message: `üî¢ Age Deal used: ${currentPlayer.name} (${currentAge}) and ${targetPlayer.name} (${targetAge}) swapped ages`,
timestamp: Date.now()
};

await updateCurrentGameState();
}

async function replaceCharacteristic(targetPlayerId, characteristicType, possibleValues) {
const targetPlayer = gameState.players.find(p => p.id === targetPlayerId);
if (!targetPlayer) return;

const oldValue = targetPlayer.characteristics[characteristicType];
const randomValue = possibleValues[Math.floor(Math.random() * possibleValues.length)];
targetPlayer.characteristics[characteristicType] = randomValue;

showNotification(`üé≤ Replaced ${targetPlayer.name}'s ${characteristicType} with ${randomValue}!`, 'success');

// Global notification for all players
gameState.lastGlobalNotification = {
message: `üé≤ Replace ${characteristicType} used: ${targetPlayer.name}'s ${characteristicType} changed from "${oldValue}" to "${randomValue}"`,
timestamp: Date.now()
};

await updateCurrentGameState();
}

function showFactReplaceModal(targetPlayerId) {
const targetPlayer = gameState.players.find(p => p.id === targetPlayerId);
if (!targetPlayer) return;

// Create modal for selecting which fact to replace
const modal = document.createElement('div');
modal.className = 'modal';
modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
  `;

const modalContent = document.createElement('div');
modalContent.style.cssText = `
      background: #2c2c54;
      padding: 20px;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      color: white;
  `;

const title = document.createElement('h3');
title.textContent = `Choose which fact to replace for ${targetPlayer.name}`;
title.style.marginBottom = '15px';
modalContent.appendChild(title);

// Add fact selection buttons
['fact1', 'fact2'].forEach(factKey => {
const factBtn = document.createElement('button');
factBtn.className = 'btn';
factBtn.textContent = `Replace ${factKey === 'fact1' ? 'First' : 'Second'} Fact`;
factBtn.style.cssText = `
          display: block;
          width: 100%;
          margin: 5px 0;
          padding: 10px;
      `;
factBtn.onclick = async () => {
const oldFact = targetPlayer.characteristics[factKey];
const randomFact = facts[Math.floor(Math.random() * facts.length)];
targetPlayer.characteristics[factKey] = randomFact;
showNotification(`üìã Replaced ${targetPlayer.name}'s ${factKey} with ${randomFact}!`, 'success');

// Global notification for all players
gameState.lastGlobalNotification = {
message: `üìã Replace Fact used: ${targetPlayer.name}'s ${factKey} changed from "${oldFact}" to "${randomFact}"`,
timestamp: Date.now()
};

await updateCurrentGameState();
document.body.removeChild(modal);
};
modalContent.appendChild(factBtn);
});

// Add cancel button
const cancelBtn = document.createElement('button');
cancelBtn.className = 'btn';
cancelBtn.textContent = 'Cancel';
cancelBtn.style.cssText = `
      display: block;
      width: 100%;
      margin: 10px 0 0 0;
      padding: 10px;
      background: #7f8c8d;
  `;
cancelBtn.onclick = () => document.body.removeChild(modal);
modalContent.appendChild(cancelBtn);

modal.appendChild(modalContent);
document.body.appendChild(modal);
}

function showUniversalChangeModal(targetPlayerId) {
const targetPlayer = gameState.players.find(p => p.id === targetPlayerId);
if (!targetPlayer) return;

// Create modal for selecting which characteristic to change
const modal = document.createElement('div');
modal.className = 'modal';
modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
  `;

const modalContent = document.createElement('div');
modalContent.style.cssText = `
      background: #2c2c54;
      padding: 20px;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      color: white;
  `;

const title = document.createElement('h3');
title.textContent = `Choose characteristic to replace for ${targetPlayer.name}`;
title.style.marginBottom = '15px';
modalContent.appendChild(title);

// Add characteristic selection buttons
const characteristics = [
{ key: 'profession', name: 'Profession', values: professions },
{ key: 'health', name: 'Health', values: health },
{ key: 'phobia', name: 'Phobia', values: phobias },
{ key: 'hobby', name: 'Hobby', values: hobbies },
{ key: 'baggage', name: 'Baggage', values: baggage },
{ key: 'fact1', name: 'First Fact', values: facts },
{ key: 'fact2', name: 'Second Fact', values: facts }
];

characteristics.forEach(char => {
const charBtn = document.createElement('button');
charBtn.className = 'btn';
charBtn.textContent = `Replace ${char.name}`;
charBtn.style.cssText = `
          display: block;
          width: 100%;
          margin: 5px 0;
          padding: 10px;
      `;
charBtn.onclick = async () => {
const oldValue = targetPlayer.characteristics[char.key];
const randomValue = char.values[Math.floor(Math.random() * char.values.length)];
targetPlayer.characteristics[char.key] = randomValue;
showNotification(`üé≤ Replaced ${targetPlayer.name}'s ${char.name} with ${randomValue}!`, 'success');

// Global notification for all players
gameState.lastGlobalNotification = {
message: `üé≤ Universal Change used: ${targetPlayer.name}'s ${char.name} changed from "${oldValue}" to "${randomValue}"`,
timestamp: Date.now()
};

await updateCurrentGameState();
document.body.removeChild(modal);
};
modalContent.appendChild(charBtn);
});

// Add cancel button
const cancelBtn = document.createElement('button');
cancelBtn.className = 'btn';
cancelBtn.textContent = 'Cancel';
cancelBtn.style.cssText = `
      display: block;
      width: 100%;
      margin: 10px 0 0 0;
      padding: 10px;
      background: #7f8c8d;
  `;
cancelBtn.onclick = () => document.body.removeChild(modal);
modalContent.appendChild(cancelBtn);

modal.appendChild(modalContent);
document.body.appendChild(modal);
}

async function stealBaggage(currentPlayer, targetPlayerId) {
const targetPlayer = gameState.players.find(p => p.id === targetPlayerId);
if (!targetPlayer) return;

// Steal target's baggage and give current player 2 baggages
const stolenBaggage = targetPlayer.characteristics.baggage;
const currentBaggage = currentPlayer.characteristics.baggage;

targetPlayer.characteristics.baggage = 'Nothing';

// Current player gets both their baggage and stolen one
currentPlayer.characteristics.baggage = `${currentBaggage}, ${stolenBaggage}`;

// Also update in gameState.players array to ensure consistency
const gameStateCurrentPlayer = gameState.players.find(p => p.id === currentPlayer.id);
const gameStateTargetPlayer = gameState.players.find(p => p.id === targetPlayer.id);

if (gameStateCurrentPlayer && gameStateTargetPlayer) {
gameStateCurrentPlayer.characteristics.baggage = currentPlayer.characteristics.baggage;
gameStateTargetPlayer.characteristics.baggage = targetPlayer.characteristics.baggage;
}

// Update currentPlayer global reference if needed
if (window.currentPlayer && window.currentPlayer.id === currentPlayer.id) {
window.currentPlayer.characteristics.baggage = currentPlayer.characteristics.baggage;
}

showNotification(`ü•∑ Stole ${stolenBaggage} from ${targetPlayer.name}!`, 'success');

// Add to audit log
gameState.auditLog.push({
timestamp: new Date().toLocaleTimeString(),
message: `ü•∑ Thief card used: ${currentPlayer.name} stole "${stolenBaggage}" from ${targetPlayer.name}`,
type: 'action'
});

// Global notification for all players
gameState.lastGlobalNotification = {
message: `ü•∑ Thief card used: ${currentPlayer.name} stole "${stolenBaggage}" from ${targetPlayer.name}`,
timestamp: Date.now()
};

await updateCurrentGameState();
}

async function swapProfessions(currentPlayer, targetPlayerId) {
const targetPlayer = gameState.players.find(p => p.id === targetPlayerId);
if (!targetPlayer) return;

// Swap professions
const currentProfession = currentPlayer.characteristics.profession;
const targetProfession = targetPlayer.characteristics.profession;

const temp = currentPlayer.characteristics.profession;
currentPlayer.characteristics.profession = targetPlayer.characteristics.profession;
targetPlayer.characteristics.profession = temp;

// Also update in gameState.players array to ensure consistency
const gameStateCurrentPlayer = gameState.players.find(p => p.id === currentPlayer.id);
const gameStateTargetPlayer = gameState.players.find(p => p.id === targetPlayer.id);

if (gameStateCurrentPlayer && gameStateTargetPlayer) {
gameStateCurrentPlayer.characteristics.profession = currentPlayer.characteristics.profession;
gameStateTargetPlayer.characteristics.profession = targetPlayer.characteristics.profession;
}

// Update currentPlayer global reference if needed
if (window.currentPlayer && window.currentPlayer.id === currentPlayer.id) {
window.currentPlayer.characteristics.profession = currentPlayer.characteristics.profession;
}

showNotification(`üîÄ Swapped professions with ${targetPlayer.name}!`, 'success');

// Add to audit log
gameState.auditLog.push({
timestamp: new Date().toLocaleTimeString(),
message: `üîÄ Job Swap used: ${currentPlayer.name} (${currentProfession}) and ${targetPlayer.name} (${targetProfession}) swapped professions`,
type: 'action'
});

// Global notification for all players
gameState.lastGlobalNotification = {
message: `üîÄ Job Swap used: ${currentPlayer.name} (${currentProfession}) and ${targetPlayer.name} (${targetProfession}) swapped professions`,
timestamp: Date.now()
};

await updateCurrentGameState();
}

function handleRevengeCard(eliminatedPlayerId) {
const eliminatedPlayer = gameState.players.find(p => p.id === eliminatedPlayerId);
if (!eliminatedPlayer || !eliminatedPlayer.hasRevengeCard) return;

// Show modal for revenge target selection
const modal = document.createElement('div');
modal.className = 'modal';
modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
  `;

const modalContent = document.createElement('div');
modalContent.style.cssText = `
      background: #2c2c54;
      padding: 20px;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      color: white;
  `;

const title = document.createElement('h3');
title.textContent = 'Revenge! Choose who to age by 20 years';
title.style.marginBottom = '15px';
modalContent.appendChild(title);

// Add player buttons (only alive players)
gameState.players.filter(p => p.isAlive && p.id !== eliminatedPlayerId).forEach(player => {
const playerBtn = document.createElement('button');
playerBtn.className = 'btn';
playerBtn.textContent = player.name;
playerBtn.style.cssText = `
          display: block;
          width: 100%;
          margin: 5px 0;
          padding: 10px;
      `;
playerBtn.onclick = () => {
const currentAge = parseInt(player.characteristics.age) || 25;
player.characteristics.age = currentAge + 20;

// Mark age as +20 if not revealed
const ageRevealed = player.revealedCharacteristics?.includes('age');
if (!ageRevealed) {
player.ageModifier = (player.ageModifier || 0) + 20;
}

showNotification(`‚ö° ${eliminatedPlayer.name}'s revenge aged ${player.name} by 20 years!`, 'success');
updateGameState();
document.body.removeChild(modal);
};
modalContent.appendChild(playerBtn);
});

modal.appendChild(modalContent);
document.body.appendChild(modal);
}

async function skipCurrentTurn() {
if (!isHost) {
showNotification('Only host can skip turns!', 'error');
return;
}

if (gameState.phase !== 'revealing') {
showNotification('Can only skip turns in revealing phase!', 'error');
return;
}

// Remove timer if exists
hideTimer();

// Use the same logic as timer expiration
await moveToNextPlayerOrEndRound();
}

let isRevealing = false;

async function revealCharacteristic(char) {
if (!currentPlayer || gameState.currentPlayerId !== currentPlayer.id) return;

// Prevent multiple reveals at once
if (isRevealing) {
console.log('‚ö†Ô∏è Already revealing, ignoring duplicate call');
return;
}

// Check if we're in revealing phase
if (gameState.phase !== 'revealing') {
console.log('‚ùå Cannot reveal - not in revealing phase');
showNotification('üö´ Not in revealing phase!', 'error');
return;
}

// Check if current player is alive
if (!currentPlayer.isAlive) {
console.log('‚ùå Cannot reveal - player is dead');
showNotification('ÔøΩ Dead players cannot reveal!', 'error');
return;
}

isRevealing = true;
console.log('ÔøΩüîç Revealing characteristic:', char, 'for player:', currentPlayer.name);

try {
const player = gameState.players.find(p => p.id === currentPlayer.id);
if (!player) {
console.error('‚ùå Player not found in game state');
return;
}

// Ensure revealedCharacteristics array exists
if (!player.revealedCharacteristics) {
player.revealedCharacteristics = [];
}
if (!currentPlayer.revealedCharacteristics) {
currentPlayer.revealedCharacteristics = [];
}

// Check if characteristic already revealed
if (player.revealedCharacteristics.includes(char)) {
console.log('‚ö†Ô∏è Characteristic already revealed');
showNotification('üö´ This characteristic is already revealed!', 'error');
return;
}

// Check reveal limit for current round
const revealedInCurrentRound = player.revealedInCurrentRound || 0;
const maxRevealsAllowed = gameState.round === 1 ? 2 : 1;
if (revealedInCurrentRound >= maxRevealsAllowed) {
console.log('‚ö†Ô∏è Already revealed maximum characteristics this round');
showNotification('üö´ You have already revealed maximum characteristics this round!', 'error');
return;
}

player.revealedCharacteristics.push(char);
currentPlayer.revealedCharacteristics.push(char);

// Increment current round counter
player.revealedInCurrentRound = (player.revealedInCurrentRound || 0) + 1;
if (currentPlayer) {
currentPlayer.revealedInCurrentRound = player.revealedInCurrentRound;
}

// Log the characteristic reveal
const charName = characteristicNames[char] || char;
const charValue = getDisplayAge(player, char);
await addToAuditLog('reveal', `${currentPlayer.name} revealed ${charName}: ${charValue}`, currentPlayer.name);

try {
// Use direct API call to ensure room ID is passed correctly
const roomId = currentPlayer.roomId || gameState.roomId || 'default';
await api.updateGameState(gameState, roomId);
console.log('‚úÖ State updated after revealing characteristic');
} catch (error) {
console.error('‚ùå Error updating game state:', error);
return;
}

// Check if current player can reveal more characteristics immediately
const currentPlayerData = gameState.players.find(p => p.id === gameState.currentPlayerId);
const revealedCount = currentPlayerData?.revealedCharacteristics?.length || 0;
const maxReveals = gameState.round === 1 ? 2 : 1;
const hasMoreToReveal = revealedCount < maxReveals;

// Always just update state and continue the current player's turn
// Don't automatically move to next player - let timer or skip button handle that
await updateCurrentGameState();
} catch (error) {
console.error('‚ùå Error in revealCharacteristic:', error);
} finally {
isRevealing = false;
}
}

async function startPreVotingDiscussion() {
gameState.phase = 'discussion';
gameState.discussionSkipVotes = [];
gameState.currentPlayerId = null; // Clear current player for discussion phase

await addToAuditLog('round', 'üí¨ Pre-voting discussion started (5 minutes)', '');

// Update state - timer will be started by updateUI() for all players
await updateCurrentGameState();
}

let isSkippingDiscussion = false;

async function skipDiscussion() {
if (!currentPlayer) return;

// Prevent multiple skip votes at once
if (isSkippingDiscussion) {
console.log('‚ö†Ô∏è Already processing skip vote, ignoring duplicate call');
return;
}

// Check if we're still in discussion phase
if (gameState.phase !== 'discussion') {
console.log('‚ö†Ô∏è Discussion already ended, ignoring skip vote');
return;
}

// Check if current player is alive
if (!currentPlayer.isAlive) {
console.log('‚ùå Cannot vote to skip - player is dead');
showNotification('üö´ Dead players cannot vote!', 'error');
return;
}

isSkippingDiscussion = true;

try {

const alivePlayers = gameState.players.filter(p => p.isAlive);
const requiredVotes = Math.ceil(alivePlayers.length * 0.5); // 50%

// Initialize skip votes array if needed
if (!gameState.discussionSkipVotes) {
gameState.discussionSkipVotes = [];
}

// Check if player already voted to skip
if (gameState.discussionSkipVotes.includes(currentPlayer.id)) {
showNotification('üö´ You already voted to skip discussion!', 'error');
return;
}

// Add player's skip vote
gameState.discussionSkipVotes.push(currentPlayer.id);
await addToAuditLog('discussion', `${currentPlayer.name} voted to skip discussion`, currentPlayer.name);

const currentVotes = gameState.discussionSkipVotes.length;

console.log(`üí¨ Skip discussion: ${currentVotes}/${requiredVotes} votes, alivePlayers: ${alivePlayers.length}`);

if (currentVotes >= requiredVotes) {
// Enough votes to skip - start voting phase
console.log('‚úÖ Enough votes to skip discussion, moving to voting phase');
gameState.phase = 'voting';
gameState.playersWhoVoted = [];
gameState.processingVoting = false;
gameState.discussionSkipVotes = [];
await addToAuditLog('discussion', `Discussion skipped (${currentVotes}/${requiredVotes} votes)`, '');
await updateCurrentGameState();
} else {
// Not enough votes yet
console.log(`‚è≥ Not enough votes yet: ${currentVotes}/${requiredVotes}`);
showNotification(`üí¨ ${currentVotes}/${requiredVotes} voted to skip`, 'info');
await updateCurrentGameState();
}
} catch (error) {
console.error('‚ùå Error in skipDiscussion:', error);
} finally {
isSkippingDiscussion = false;
}
}

async function vote(playerId) {
console.log(`üó≥Ô∏è Vote function called for player ${playerId}, hasVoted: ${hasVoted}`);

// Check if current player is alive
if (!currentPlayer || !currentPlayer.isAlive) {
console.log('‚ùå Cannot vote - player is dead');
showNotification('üö´ Dead players cannot vote!', 'error');
return;
}

// Check if we're in voting phase
if (gameState.phase !== 'voting') {
console.log('‚ùå Cannot vote - not in voting phase');
showNotification('üö´ Voting is not active!', 'error');
return;
}

// Check if player can vote (not blocked by action card)
const voter = gameState.players.find(p => p.id === currentPlayer?.id);
if (voter?.cannotVote) {
console.log('‚ùå Cannot vote - blocked by action card');
showNotification('üö´ You cannot vote this round!', 'error');
return;
}

if (hasVoted) {
console.log('‚ùå Already voted, returning');
return;
}

// Double check if player already voted in the server state
gameState.playersWhoVoted = gameState.playersWhoVoted || [];
if (gameState.playersWhoVoted.includes(currentPlayer?.id)) {
console.log('‚ùå Player already voted in server state');
hasVoted = true;
showNotification('üö´ You have already voted!', 'error');
return;
}

// Prevent multiple rapid clicks
if (gameState.processingVoting) {
console.log('‚ùå Voting is being processed, ignoring click');
return;
}

gameState.votingResults = gameState.votingResults || {};
gameState.detailedVotes = gameState.detailedVotes || {};

// Check for double vote effect
const voteWeight = voter?.hasDoubleVote ? 2 : 1;
gameState.votingResults[playerId] = (gameState.votingResults[playerId] || 0) + voteWeight;

// Track detailed votes (who voted for whom)
if (!gameState.detailedVotes[playerId]) {
gameState.detailedVotes[playerId] = [];
}
gameState.detailedVotes[playerId].push({
voterId: currentPlayer.id,
voterName: currentPlayer.name,
weight: voteWeight
});

console.log(`üìä Added detailed vote: ${currentPlayer.name} voted for ${gameState.players.find(p => p.id === playerId)?.name}`);
console.log('üìä Current detailed votes:', gameState.detailedVotes);

// Log the vote
const targetPlayerName = gameState.players.find(p => p.id === playerId)?.name || 'Unknown';
const voteMessage = voteWeight > 1 ? 
    `${currentPlayer.name} voted for ${targetPlayerName} (double vote)` :
    `${currentPlayer.name} voted for ${targetPlayerName}`;
addToAuditLog('vote', voteMessage, currentPlayer.name);

// Update votesReceived immediately for real-time display
const targetPlayer = gameState.players.find(p => p.id === playerId);
if (targetPlayer) {
targetPlayer.votesReceived = gameState.votingResults[playerId];
console.log(`üìä Updated votesReceived for ${targetPlayer.name}: ${targetPlayer.votesReceived}`);
}

hasVoted = true;
// Immediately add to server-side voted list
if (!gameState.playersWhoVoted.includes(currentPlayer.id)) {
gameState.playersWhoVoted.push(currentPlayer.id);
}

console.log(`‚úÖ Vote cast successfully (weight: ${voteWeight}), hasVoted set to true`);
console.log('üìä Current voting results:', gameState.votingResults);
console.log('üìä Players who voted:', gameState.playersWhoVoted);

// Clear double vote effect after use
if (voter?.hasDoubleVote) {
voter.hasDoubleVote = false;
showNotification('üó≥Ô∏è Double vote used!', 'success');
}

try {
await updateCurrentGameState();
console.log('‚úÖ Vote state updated on server');
} catch (error) {
console.error('‚ùå Failed to update vote state:', error);
}

// Update UI immediately to show the vote
updateUI();

console.log('üìä Vote recorded, waiting before checking completion...');
// –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–±–æ–ª—å—à—É—é –∑–∞–¥–µ—Ä–∂–∫—É –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
await new Promise(resolve => setTimeout(resolve, 500));

const alivePlayers = gameState.players.filter(p => p.isAlive);
const votedCount = gameState.playersWhoVoted.length;

console.log(`üî¢ Vote count check: ${votedCount}/${alivePlayers.length} players voted`);
console.log('üìä Players who voted:', gameState.playersWhoVoted);

if (votedCount >= alivePlayers.length) {
console.log('‚úÖ All players voted, processing voting in 2 seconds...');
setTimeout(async () => {
await processVoting();
}, 2000);
} else {

console.log(`‚è≥ Waiting for more votes: ${alivePlayers.length - votedCount} votes remaining`);
}
}

async function processVoting() {
console.log('üó≥Ô∏è Processing voting, votingResults:', gameState.votingResults);

// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –ª–∏ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ —É–∂–µ
if (gameState.processingVoting) {
console.log('‚ö†Ô∏è Voting is already being processed, skipping...');
return;
}

// –ü–æ–º–µ—á–∞–µ–º, —á—Ç–æ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è
gameState.processingVoting = true;

let maxVotes = 0;
let eliminatedId = null;

Object.entries(gameState.votingResults || {}).forEach(([playerId, votes]) => {
console.log(`Player ${playerId} received ${votes} votes`);
if (votes > maxVotes) {
maxVotes = votes;
eliminatedId = playerId;
}
const player = gameState.players.find(p => p.id === playerId);
if (player) player.votesReceived = votes;
});

console.log(`üéØ Player to eliminate: ${eliminatedId} with ${maxVotes} votes`);

if (eliminatedId) {
const eliminated = gameState.players.find(p => p.id === eliminatedId);
if (eliminated) {
// Check for immunity
if (eliminated.hasImmunity) {
console.log(`üõ°Ô∏è ${eliminated.name} has immunity and cannot be eliminated!`);
showNotification(`üõ°Ô∏è ${eliminated.name} used immunity and cannot be eliminated!`, 'info');

// Clear immunity after use
eliminated.hasImmunity = false;

// Find next player with most votes (excluding immune player)
let nextMaxVotes = 0;
let nextEliminatedId = null;

Object.entries(gameState.votingResults || {}).forEach(([playerId, votes]) => {
if (playerId !== eliminatedId && votes > nextMaxVotes) {
nextMaxVotes = votes;
nextEliminatedId = playerId;
}
});

if (nextEliminatedId && nextMaxVotes > 0) {
const nextEliminated = gameState.players.find(p => p.id === nextEliminatedId);
if (nextEliminated) {
nextEliminated.isAlive = false;
console.log(`üíÄ Next player eliminated: ${nextEliminated.name} with ${nextMaxVotes} votes`);
addToAuditLog('elimination', `${nextEliminated.name} was eliminated with ${nextMaxVotes} votes (after ${eliminated.name} used immunity)`, nextEliminated.name);
}
} else {
console.log('‚ùå No other player to eliminate this round');
addToAuditLog('elimination', `No elimination this round (${eliminated.name} used immunity, no other candidates)`, '');
}
} else {
eliminated.isAlive = false;
console.log(`üíÄ Eliminated player: ${eliminated.name}`);
addToAuditLog('elimination', `${eliminated.name} was eliminated with ${maxVotes} votes`, eliminated.name);

// Handle revenge card if eliminated player has one
if (eliminated.hasRevengeCard) {
handleRevengeCard(eliminated.id);
}
}

// –ï—Å–ª–∏ –∏—Å–∫–ª—é—á–µ–Ω–Ω—ã–π –∏–≥—Ä–æ–∫ –±—ã–ª —Ö–æ—Å—Ç–æ–º, –æ–Ω –æ—Å—Ç–∞–µ—Ç—Å—è —Ö–æ—Å—Ç–æ–º –Ω–æ –Ω–µ —É—á–∞—Å—Ç–≤—É–µ—Ç –≤ –∏–≥—Ä–µ
if (eliminated.id === gameState.hostId) {
console.log('üëë Host was eliminated but remains host for game management');
}
}

await updateCurrentGameState();
console.log('üì§ Updated game state on server after elimination');

setTimeout(async () => {
// –£–±–∏—Ä–∞–µ–º —Ñ–ª–∞–≥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—è —Å—Ä–∞–∑—É
gameState.processingVoting = false;
    
const remaining = gameState.players.filter(p => p.isAlive);
console.log(`üéÆ After elimination: ${remaining.length} players remaining, ${gameState.bunkerSlots} bunker slots`);

if (remaining.length <= gameState.bunkerSlots) {
console.log('üèÅ Game should end - remaining players <= bunker slots');
await endGame();
} else {
console.log('üîÑ Starting next round - more players than bunker slots');
await startNextRound();
}

await updateCurrentGameState();
}, 2000);
} else {
console.log('‚ùå No player to eliminate');
// –£–±–∏—Ä–∞–µ–º —Ñ–ª–∞–≥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—è
// –£–±–∏—Ä–∞–µ–º —Ñ–ª–∞–≥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—è –∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
gameState.processingVoting = false;
await updateCurrentGameState();
}
}

async function startNextRound() {
console.log('üîÑ Starting next round...');
gameState.round++;
addToAuditLog('round', `--- Round ${gameState.round} started ---`, '');

gameState.phase = 'revealing';
gameState.votingResults = {};
gameState.playersWhoVoted = []; // Reset voting list
gameState.discussionSkipVotes = []; // Reset discussion skip votes

// –í—ã–±–∏—Ä–∞–µ–º –ø–µ—Ä–≤–æ–≥–æ –∂–∏–≤–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞—É–Ω–¥–∞
const alivePlayers = gameState.players.filter(p => p.isAlive);
gameState.currentPlayerId = alivePlayers.length > 0 ? alivePlayers[0].id : null;

hasVoted = false;

// Reset current round counters for currentPlayer too
if (currentPlayer) {
currentPlayer.revealedInCurrentRound = 0;
}

gameState.players.forEach(p => {
p.votesReceived = 0;
// Reset action card effects for new round
p.hasImmunity = false;
p.hasDoubleVote = false;
p.cannotVote = false;
// Reset revealed count for current round
p.revealedInCurrentRound = 0;
// DON'T reset revealed characteristics - they should stay visible
});

console.log(`üéØ Next round setup: Round ${gameState.round}, First player: ${gameState.currentPlayerId}, ${alivePlayers.length} alive players`);

if (!gameState.currentPlayerId) {
console.error('‚ùå No alive players found for next round!');
await endGame();
return;
}

// Update state for all players and start timer for first player
await updateCurrentGameState();
console.log('‚úÖ Next round state updated for all players');

// Force UI update to ensure timer starts
setTimeout(() => {
console.log('üîÑ Force updating UI after round start');
updateUI();

// Additional check - if current player should have timer but doesn't, force start it
if (gameState.phase === 'revealing' && gameState.currentPlayerId && currentPlayer) {
const isCurrentPlayer = gameState.currentPlayerId === currentPlayer.id;
const hasTimer = !!document.getElementById('gameTimer');

console.log(`üîç Additional timer check: isCurrentPlayer=${isCurrentPlayer}, hasTimer=${hasTimer}`);
        
if (isCurrentPlayer && !hasTimer) {
console.log('üéØ Force starting timer for current player');
startRevealTimer();
}
}
}, 500);
}

async function forceEndGame() {
if (!isHost) {
showNotification('Only host can end game!', 'error');
return;
}

if (gameState.phase === 'ended') {
showNotification('–ò–≥—Ä–∞ —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!', 'error');
return;
}

// –ó–∞–≤–µ—Ä—à–∞–µ–º –∏–≥—Ä—É —Å —Ç–µ–∫—É—â–∏–º–∏ –∂–∏–≤—ã–º–∏ –∏–≥—Ä–æ–∫–∞–º–∏ –∫–∞–∫ –≤—ã–∂–∏–≤—à–∏–º–∏
hideTimer();
await endGame();
}

async function endGame() {
console.log('üèÅ Ending game...');
gameState.phase = 'ended';
gameState.lastUpdate = Date.now(); // –í–∞–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å timestamp
await updateCurrentGameState();
console.log('‚úÖ Game ended, state updated on server');

// –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —É–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤ –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∏–≥—Ä—ã
console.log('üì¢ Broadcasting game end to all players');

// Clear stored player data when game ends
clearStoredPlayerData();
console.log('üßπ Cleared stored player data');

showScreen('gameEnd');
updateSurvivors();
}

function updateSurvivors() {
elements.survivors.innerHTML = '';
gameState.players.filter(p => p.isAlive).forEach(player => {
const div = document.createElement('div');
div.className = 'survivor';
const hostIcon = player.id === gameState.hostId ? 'üëë ' : '';
div.textContent = hostIcon + player.name;
elements.survivors.appendChild(div);
});
}

async function restartGame() {
if (!isHost) {
showNotification('Only host can restart the game!', 'error');
return;
}

// –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã, –Ω–æ –æ—Å—Ç–∞–≤–ª—è–µ–º –∏–≥—Ä–æ–∫–æ–≤ –≤ –ª–æ–±–±–∏
gameState.phase = 'waiting';
gameState.round = 1;
gameState.currentPlayerId = null;
gameState.votingResults = {};

// –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤
gameState.players.forEach(player => {
player.isAlive = true;
player.votesReceived = 0;
player.revealedCharacteristics = [];
player.characteristics = generateRandomCharacteristics();
});

hasVoted = false;

await api.updateGameState(gameState);

showScreen('waiting');
updateWaitingScreen();
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞—É–Ω–¥–∞ —Ä–∞—Å–∫—Ä—ã—Ç–∏–π
function checkRoundComplete() {
const alivePlayers = gameState.players.filter(p => p.isAlive);
const maxReveals = gameState.round === 1 ? 2 : 1;

return alivePlayers.every(player => {
const revealedCount = player.revealedCharacteristics?.length || 0;
return revealedCount >= maxReveals;
});
}

// –¢–∞–π–º–µ—Ä –¥–ª—è —Ä–∞—Å–∫—Ä—ã—Ç–∏—è —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
function startRevealTimer() {
const currentPlayerName = gameState.players.find(p => p.id === gameState.currentPlayerId)?.name || '–ò–≥—Ä–æ–∫';
showTimer(60, `üéØ ${currentPlayerName}, choose a characteristic to reveal`, async () => {
// Timer finished - move to next player or end round
await moveToNextPlayerOrEndRound();
}, true); // Add skip button
}

async function moveToNextPlayerOrEndRound() {
const alivePlayers = gameState.players.filter(p => p.isAlive);
const currentIndex = alivePlayers.findIndex(p => p.id === gameState.currentPlayerId);
const nextIndex = (currentIndex + 1) % alivePlayers.length;
const maxReveals = gameState.round === 1 ? 2 : 1;

// Check if round is complete
if (nextIndex === 0 && checkRoundComplete()) {
// All players revealed characteristics, start 5-minute discussion phase
await startPreVotingDiscussion();
} else if (nextIndex === 0) {
// Completed full circle but not everyone revealed enough
// Find first player who can still reveal
const playerWithMoreToReveal = alivePlayers.find(p => {
const revealedCount = p.revealedCharacteristics?.length || 0;
return revealedCount < maxReveals;
});

if (playerWithMoreToReveal) {
gameState.currentPlayerId = playerWithMoreToReveal.id;
await updateCurrentGameState();
} else {
// Everyone revealed enough, start 5-minute discussion phase
await startPreVotingDiscussion();
}
} else {
// Move to next player
gameState.currentPlayerId = alivePlayers[nextIndex].id;
await updateCurrentGameState();
}
}

// –§—É–Ω–∫—Ü–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
function showNotification(message, type = 'info') {
const notification = document.createElement('div');
notification.className = `notification ${type}`;
notification.textContent = message;
document.body.appendChild(notification);

setTimeout(() => {
notification.classList.add('show');
}, 100);

setTimeout(() => {
notification.classList.remove('show');
setTimeout(() => {
if (notification.parentNode) {
document.body.removeChild(notification);
}
}, 300);
}, 3000);
}

function showActionCardNotification(message) {
const notification = document.createElement('div');
notification.className = 'action-card-notification';
notification.style.cssText = `
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: linear-gradient(135deg, #8B5CF6, #A855F7);
color: white;
padding: 20px 30px;
border-radius: 15px;
box-shadow: 0 10px 30px rgba(139, 92, 246, 0.3);
z-index: 10000;
font-size: 18px;
font-weight: bold;
text-align: center;
opacity: 0;
transition: all 0.5s ease;
border: 2px solid rgba(255, 255, 255, 0.2);
backdrop-filter: blur(10px);
`;
notification.textContent = 'üé¥ ' + message;
document.body.appendChild(notification);

setTimeout(() => {
notification.style.opacity = '1';
notification.style.transform = 'translate(-50%, -50%) scale(1.05)';
}, 100);

setTimeout(() => {
notification.style.transform = 'translate(-50%, -50%) scale(1)';
}, 600);

setTimeout(() => {
notification.style.opacity = '0';
notification.style.transform = 'translate(-50%, -50%) scale(0.9)';
setTimeout(() => {
if (notification.parentNode) {
document.body.removeChild(notification);
}
}, 500);
}, 4000);
}

// –§—É–Ω–∫—Ü–∏–∏ —Ç–∞–π–º–µ—Ä–∞
function showTimer(seconds, message, onComplete, canSkip = false, options = {}) {
hideTimer(); // –°–∫—Ä—ã–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–µ—Ä –µ—Å–ª–∏ –µ—Å—Ç—å

const timerContainer = document.createElement('div');
timerContainer.className = 'timer-container';
timerContainer.id = 'gameTimer';

const messageEl = document.createElement('div');
messageEl.className = 'timer-message';
messageEl.textContent = message;

const displayEl = document.createElement('div');
displayEl.className = 'timer-display';
displayEl.textContent = seconds;

timerContainer.appendChild(messageEl);
timerContainer.appendChild(displayEl);

if (canSkip) {
const skipBtn = document.createElement('button');
skipBtn.className = 'timer-skip-btn';
skipBtn.textContent = 'Skip';
skipBtn.onclick = () => {
hideTimer();
if (onComplete) onComplete();
};
timerContainer.appendChild(skipBtn);
}

// Support for custom skip button
if (options.skipButton) {
const skipBtn = document.createElement('button');
skipBtn.className = 'timer-skip-btn discussion-skip-btn';
skipBtn.textContent = options.skipText || 'Skip';
skipBtn.onclick = () => {
if (options.skipAction) options.skipAction();
};
timerContainer.appendChild(skipBtn);
}

document.body.appendChild(timerContainer);

let timeLeft = seconds;
timerInterval = setInterval(() => {
timeLeft--;
displayEl.textContent = timeLeft;

if (timeLeft <= 0) {
hideTimer();
if (onComplete) onComplete();
}
}, 1000);
}

function hideTimer() {
if (timerInterval) {
clearInterval(timerInterval);
timerInterval = null;
}
const timer = document.getElementById('gameTimer');
if (timer) {
document.body.removeChild(timer);
}
}

// Audit Log Functions
async function addToAuditLog(type, message, playerName = '') {
const timestamp = new Date().toLocaleTimeString();
const logEntry = {
type: type,
message: message,
playerName: playerName,
timestamp: timestamp,
round: gameState?.round || 1
};

// Store in global game state so all players can see it
if (!gameState.auditLog) {
gameState.auditLog = [];
}

gameState.auditLog.push(logEntry);
updateAuditLogDisplay();

// Force immediate sync to ensure other players see the log
try {
await updateCurrentGameState();
} catch (error) {
console.error('Failed to sync audit log:', error);
}
}

function updateAuditLogDisplay() {
if (!elements.auditLogContent) return;

const logs = gameState?.auditLog || [];

elements.auditLogContent.innerHTML = '';

if (logs.length === 0) {
const emptyMsg = document.createElement('div');
emptyMsg.className = 'audit-log-entry';
emptyMsg.innerHTML = '<div class="action">No actions yet...</div>';
elements.auditLogContent.appendChild(emptyMsg);
return;
}

// Show recent entries first
const recentEntries = logs.slice().reverse();

recentEntries.forEach(entry => {
const entryElement = document.createElement('div');
entryElement.className = `audit-log-entry ${entry.type}`;

entryElement.innerHTML = `
<div class="timestamp">Round ${entry.round} - ${entry.timestamp}</div>
<div class="action">${entry.message}</div>
`;
elements.auditLogContent.appendChild(entryElement);
});
}

function toggleAuditLog() {
if (elements.auditLogPanel.classList.contains('show')) {
closeAuditLog();
} else {
elements.auditLogPanel.classList.add('show');
updateAuditLogDisplay();
}
}

function closeAuditLog() {
elements.auditLogPanel.classList.remove('show');
}

function clearAuditLog() {
if (gameState) {
gameState.auditLog = [];
}
updateAuditLogDisplay();
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã
window.addEventListener('beforeunload', () => {
if (syncInterval) {
clearInterval(syncInterval);
}
if (timerInterval) {
clearInterval(timerInterval);
}
});

// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Å—Ç–∞—Ä—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
document.addEventListener('DOMContentLoaded', async () => {
console.log('üéÆ Bunker Game –∑–∞–ø—É—â–µ–Ω!');

setupEventListeners();
showScreen('lobby');

// –ù–ï –∑–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –±–µ–∑ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –∫–æ–º–Ω–∞—Ç–µ
// –°–æ—Å—Ç–æ—è–Ω–∏–µ –±—É–¥–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–æ —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞ –∫ –∫–æ–º–Ω–∞—Ç–µ
console.log('ÔøΩ Ready to join room');
});
</script>